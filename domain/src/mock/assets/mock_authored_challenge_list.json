{
  "data": [
    {
      "id": "54d7660d2daf68c619000d95",
      "name": "Common Denominators",
      "description": "Common denominators\r\n\r\n You will have a list of rationals in the form \r\n ```\r\n { {numer_1, denom_1} , ... {numer_n, denom_n} } \r\n ```\r\n or\r\n ```\r\n [ [numer_1, denom_1] , ... [numer_n, denom_n] ] \r\n ``` \r\n or\r\n ```\r\n [ (numer_1, denom_1) , ... (numer_n, denom_n) ] \r\n ```\r\n \r\n \r\n where all numbers are positive ints.\r\n \r\n You have to produce a result in the form \r\n ```\r\n (N_1, D) ... (N_n, D) \r\n ```\r\n or\r\n ```\r\n [ [N_1, D] ... [N_n, D] ] \r\n ```\r\nor\r\n ```\r\n [ (N_1', D) , ... (N_n, D) ] \r\n ```\r\nor\r\n```\r\n{{N_1, D} ... {N_n, D}} \r\n```\r\nor\r\n```\r\n\"(N_1, D) ... (N_n, D)\"\r\n```\r\n\r\ndepending on the language (See Example tests)\r\n\r\n in which D is as small as possible\r\n and \r\n \r\n ```\r\n N_1/D == numer_1/denom_1 ... N_n/D == numer_n,/denom_n.\r\n ```\r\n \r\nExample: \r\n \r\n```\r\nconvertFracs [(1, 2), (1, 3), (1, 4)] `shouldBe` [(6, 12), (4, 12), (3, 12)]\r\n```\r\n\r\n# Note: \r\nDue to the fact that first translations were written long ago - more than 4 years - these translations have only irreducible fractions. Newer translations have some reducible fractions. To be on the safe side it is better to do a bit more work by simplifying fractions even if they don't have to be.\r\n\r\n# Note for Bash:\r\ninput is a string,  e.g `\"2,4,2,6,2,8\"`\r\n\r\noutput is  then         `\"6 12 4 12 3 12\"`",
      "rank": -5,
      "rankName": "5 kyu",
      "tags": [
        "Fundamentals",
        "Algorithms",
        "Logic",
        "Mathematics",
        "Numbers"
      ],
      "languages": [
        "java",
        "ruby",
        "csharp",
        "python",
        "clojure",
        "haskell",
        "javascript",
        "coffeescript",
        "cpp",
        "php",
        "crystal",
        "c",
        "typescript",
        "rust",
        "swift",
        "r",
        "shell",
        "ocaml",
        "elixir",
        "fsharp",
        "julia",
        "scala",
        "powershell",
        "go",
        "nim",
        "purescript",
        "racket",
        "reason",
        "kotlin",
        "groovy"
      ]
    },
    {
      "id": "54d496788776e49e6b00052f",
      "name": "Sum by Factors",
      "description": "Given an array of positive or negative integers \n\n<code> I= [i<sub>1</sub>,..,i<sub>n</sub>]</code>\n\nyou have to produce a sorted array P of the form \n\n<code>[ [p, sum of all i<sub>j</sub> of I for which p is a prime factor (p positive) of i<sub>j</sub>] ...]</code>\n\nP will be sorted by increasing order of the prime numbers.\nThe final result has to be given as a string in Java, C#, C, C++ and as an array of arrays in other languages.\n\nExample:\n\n```fortran\nI = (/12, 15/); // result = \"(2 12)(3 27)(5 15)\"\n```\n```python\nI = [12, 15] # result = [[2, 12], [3, 27], [5, 15]]\n```\n```elixir\nI = [12, 15] # result = [{2, 12}, {3, 27}, {5, 15}]\n```\n```rust\nI = [12, 15] # result = [(2, 12), (3, 27), (5, 15)]\n```\n```swift\nI = [12, 15] # result = [(2, 12), (3, 27), (5, 15)]\n```\n```ruby\nI = [12, 15] # result = [[2, 12], [3, 27], [5, 15]]\n```\n```java\nI = {12, 15}; // result = \"(2 12)(3 27)(5 15)\"\n```\n```cpp\nI = {12, 15}; // result = \"(2 12)(3 27)(5 15)\"\n```\n```c\nI = {12, 15}; // result = \"(2 12)(3 27)(5 15)\"\n```\n```csharp\nI = {12, 15}; // result = \"(2 12)(3 27)(5 15)\"\n```\n```clojure\nI = [12, 15] ; result = [[2, 12], [3, 27], [5, 15]]\n```\n```haskell\nI = [12, 15] -- result = [(2,12),(3,27),(5,15)]\n```\n```javascript\nI = [12, 15]; //result = [[2, 12], [3, 27], [5, 15]]\n```\n```coffeescript\nI = [12, 15] # result = [[2, 12], [3, 27], [5, 15]]\n```\n```typescript\nI = [12, 15]; //result = [[2, 12], [3, 27], [5, 15]]\n```\n```php\nI = [12, 15]; //result = [[2, 12], [3, 27], [5, 15]]\n```\n\n[2, 3, 5] is the list of all prime factors of the elements of I, hence the result.\n\n**Notes:**\n- It can happen that a sum is 0 if some numbers are negative!\n\nExample: I = [15, 30, -45]\n5 divides 15, 30 and (-45) so 5 appears in the result, the sum of the numbers for which 5 is a factor is 0 so we have [5, 0] in the result amongst others. \n\n- In Fortran - as in any other language - the returned string is not permitted to contain any redundant trailing whitespace: you can use dynamically allocated character strings.\n\n\n",
      "rank": -4,
      "rankName": "4 kyu",
      "tags": [
        "Algorithms",
        "Numbers",
        "Data Types",
        "Arrays"
      ],
      "languages": [
        "java",
        "python",
        "csharp",
        "ruby",
        "clojure",
        "haskell",
        "javascript",
        "coffeescript",
        "cpp",
        "typescript",
        "elixir",
        "php",
        "crystal",
        "c",
        "rust",
        "swift",
        "fsharp",
        "r",
        "shell",
        "ocaml",
        "kotlin",
        "fortran",
        "groovy",
        "julia",
        "scala",
        "powershell",
        "go",
        "nim",
        "reason",
        "racket",
        "vb",
        "haxe"
      ]
    },
    {
      "id": "54d512e62a5e54c96200019e",
      "name": "Primes in numbers",
      "description": "Given a positive number n > 1 find the prime factor decomposition of n.\nThe result will be a string with the following form :\n```\n \"(p1**n1)(p2**n2)...(pk**nk)\"\n```\nwhere ```a ** b``` means ```a``` to the power of ```b```\n\nwith the p(i) in increasing order and n(i) empty if\nn(i) is 1.\n```\nExample: n = 86240 should return \"(2**5)(5)(7**2)(11)\"\n```",
      "rank": -5,
      "rankName": "5 kyu",
      "tags": [
        "Fundamentals",
        "Numbers",
        "Data Types",
        "Mathematics",
        "Algorithms",
        "Logic",
        "Utilities"
      ],
      "languages": [
        "java",
        "ruby",
        "python",
        "csharp",
        "clojure",
        "javascript",
        "haskell",
        "coffeescript",
        "cpp",
        "php",
        "crystal",
        "swift",
        "c",
        "typescript",
        "rust",
        "r",
        "shell",
        "fsharp",
        "ocaml",
        "elixir",
        "groovy",
        "julia",
        "scala",
        "powershell",
        "go",
        "nim",
        "racket",
        "reason",
        "kotlin",
        "prolog",
        "haxe"
      ]
    },
    {
      "id": "54de3257f565801d96001200",
      "name": "Ease the StockBroker",
      "description": "Clients place orders to a stockbroker as strings. The order can be simple or multiple.\n  \n  Type of a simple order: Quote/white-space/Quantity/white-space/Price/white-space/Status\n  \n  where Quote is formed of non-whitespace character, \n  Quantity is an int, \n  Price a double (with mandatory decimal point \".\" ), \n  Status is represented by the letter B (buy) or the letter S (sell).\n  \n  Example: \n  \n  `\"GOOG 300 542.0 B\"`\n  \n  A multiple order is the concatenation of simple orders with a comma between each.\n  \n  Example: \n  \n  `\"ZNGA 1300 2.66 B, CLH15.NYM 50 56.32 B, OWW 1000 11.623 B, OGG 20 580.1 B\"`\n  \n  or (C)\n  \n  `\"ZNGA 1300 2.66 B,CLH15.NYM 50 56.32 B,OWW 1000 11.623 B,OGG 20 580.1 B\"`\n  \n  To ease the stockbroker your task is to produce a string of type\n  \n`\"Buy: b Sell: s\"`\n  where b and s are 'double' \n  formatted with no decimal, b representing the total price of bought stocks and s the total price of sold stocks.\n  \n  Example: \n  \n  `\"Buy: 294990 Sell: 0\"`\n  \n  Unfortunately sometimes clients make mistakes. When you find mistakes in orders, you must pinpoint these badly formed orders\n  and produce a string of type:\n  \n  `\"Buy: b Sell: s; Badly formed nb: badly-formed 1st simple order ;badly-formed nth simple order ;\"`\n  \n  where nb is the number of badly formed simple orders, b representing the total price of bought stocks\n  with correct simple order and s the total price of sold stocks with correct simple order.\n  \n  Examples: \n  \n  `\"Buy: 263 Sell: 11802; Badly formed 2: CLH16.NYM 50 56 S ;OWW 1000 11 S ;\"`\n  \n  `\"Buy: 100 Sell: 56041; Badly formed 1: ZNGA 1300 2.66 ;\"`\n  \n  Notes:\n  - Due to Codewars whitespace differences will not always show up in test results.\n  - With Golang use a format with \"%.0f\" for \"Buy\" and \"Sell\".",
      "rank": -6,
      "rankName": "6 kyu",
      "tags": [
        "Fundamentals",
        "Strings",
        "Data Types"
      ],
      "languages": [
        "java",
        "csharp",
        "javascript",
        "python",
        "ruby",
        "coffeescript",
        "clojure",
        "haskell",
        "cpp",
        "php",
        "c",
        "typescript",
        "swift",
        "crystal",
        "r",
        "shell",
        "ocaml",
        "julia",
        "scala",
        "go",
        "rust",
        "fsharp",
        "kotlin",
        "groovy"
      ]
    },
    {
      "id": "54dc6f5a224c26032800005c",
      "name": "Help the bookseller !",
      "description": "A bookseller has lots of books classified in 26 categories labeled A, B, ... Z. \nEach book has a code `c` of 3, 4, 5 or more characters. The **1st** character of a code is a capital letter which defines the book category.\n  \n  In the bookseller's stocklist each code `c` is followed by a space and by a positive integer n (int n >= 0) \n  which indicates the quantity of books of this code in stock.\n\nFor example an extract of a stocklist could be:\n```\nL = {\"ABART 20\", \"CDXEF 50\", \"BKWRK 25\", \"BTSQZ 89\", \"DRTYM 60\"}.\nor\nL = [\"ABART 20\", \"CDXEF 50\", \"BKWRK 25\", \"BTSQZ 89\", \"DRTYM 60\"] or ....\n```\n\n  You will be given a stocklist (e.g. : L) and a list of categories in capital letters \n  e.g : \n```\nM = {\"A\", \"B\", \"C\", \"W\"} \nor\nM = [\"A\", \"B\", \"C\", \"W\"] or ...\n```\n  \n  and your task is to find all the books of L with codes \n  belonging to each category of M and to sum their quantity according to each category. \n\n\n  For the lists L and M of example you have to return the string (in Haskell/Clojure/Racket a list of pairs):  \n  ```\n  (A : 20) - (B : 114) - (C : 50) - (W : 0)\n  ```  \n\n  where A, B, C, W are the categories, 20 is the sum of the unique book of category A, 114 the sum corresponding\n  to \"BKWRK\" and \"BTSQZ\", 50 corresponding to \"CDXEF\" and 0 to category 'W' since there are no code beginning with W.\n\n  If L or M are empty return string is `\"\"` (Clojure and Racket should return an empty array/list instead).\n  \n## Note:\nIn the result codes and their values are in the same order as in M.\n",
      "rank": -6,
      "rankName": "6 kyu",
      "tags": [
        "Fundamentals",
        "Algorithms",
        "Logic"
      ],
      "languages": [
        "java",
        "ruby",
        "python",
        "csharp",
        "javascript",
        "clojure",
        "haskell",
        "coffeescript",
        "cpp",
        "php",
        "c",
        "typescript",
        "swift",
        "crystal",
        "r",
        "shell",
        "ocaml",
        "fsharp",
        "julia",
        "scala",
        "go",
        "nim",
        "rust",
        "racket",
        "kotlin",
        "groovy"
      ]
    },
    {
      "id": "54db15b003e88a6a480000b9",
      "name": "Moduli number system",
      "description": "A number system with moduli is deﬁned by a vector of k moduli, `[m1,m2, ···,mk]`. \n  \nThe moduli must be `pairwise co-prime`, which means that, for any pair of moduli, the only common factor is `1`. \n\nIn such a system each number `n` is represented by a string `\"-x1--x2-- ... --xk-\"` of its residues, one for each modulus. \nThe product `m1 * ... * mk` must be greater than the given number `n` which is to be converted in the moduli number system.\n \nFor example, if we use the system `[2, 3, 5]` the number `n = 11` is represented by `\"-1--2--1-\"`,  \nthe number `n = 23` by `\"-1--2--3-\"`. \n\nIf we use the system `[8, 7, 5, 3]` the number `n = 187` becomes\n`\"-3--5--2--1-\"`.\n \nYou will be given a number `n (n >= 0)` and a system `S = [m1,m2, ···,mk]` and you will return a string\n`\"-x1--x2-- ...--xk-\"` representing the number `n` in the system `S`.\n \nIf the moduli are not `pairwise co-prime` or if the product `m1 * ... * mk` is not greater than `n`, return `\"Not applicable\"`.\n\n**Examples:** (you can add them in the \"Sample tests\")\n\n```\nfromNb2Str(11, [2,3,5]) -> \"-1--2--1-\"\n\nfromNb2Str(6, [2, 3, 4]) -> \"Not applicable\", since 2 and 4 are not coprime\n\nfromNb2Str(7, [2, 3]) -> \"Not applicable\" since 2 * 3 < 7\n```\n\n\n\n",
      "rank": -6,
      "rankName": "6 kyu",
      "tags": [
        "Fundamentals",
        "Numbers",
        "Data Types"
      ],
      "languages": [
        "java",
        "csharp",
        "ruby",
        "python",
        "clojure",
        "javascript",
        "haskell",
        "coffeescript",
        "cpp",
        "php",
        "crystal",
        "c",
        "typescript",
        "rust",
        "swift",
        "r",
        "shell",
        "ocaml",
        "fsharp",
        "julia",
        "scala",
        "go",
        "nim",
        "racket",
        "reason",
        "kotlin",
        "groovy",
        "prolog",
        "haxe"
      ]
    },
    {
      "id": "54e320dcebe1e583250008fd",
      "name": "Decimal to Factorial and Back",
      "description": "Coding decimal numbers with factorials is a way of writing out numbers \nin a base system that depends on factorials, rather than powers of numbers.\n\nIn this system, the last digit is always `0` and is in base 0!. The digit before that is either `0 or 1` and is in base 1!.  The digit before that is either `0, 1, or 2` and is in base 2!, etc.\nMore generally, the nth-to-last digit is always `0, 1, 2, ..., n` and is in base n!.\n\nRead more about it at: http://en.wikipedia.org/wiki/Factorial_number_system\n\n\n## Example\n\nThe decimal number `463` is encoded as `\"341010\"`, because:\n\n463 = 3×5! + 4×4! + 1×3! + 0×2! + 1×1! + 0×0!\n\n\nIf we are limited to digits `0..9`, the biggest number we can encode is 10!-1 (= 3628799). So we extend `0..9` with letters `A..Z`. With these 36 digits we can now encode numbers up to 36!-1 (= 3.72 × 10<sup>41</sup>)\n\n\n## Task\n\nWe will need two functions. The first one will receive a decimal number and return a string with the factorial representation.\n\n~~~if:java\n**Note:** the input number is at most a long.\n~~~\n\nThe second one will receive a string with a factorial representation and produce the decimal representation.\n\nGiven numbers will always be positive.\n",
      "rank": -5,
      "rankName": "5 kyu",
      "tags": [
        "Algorithms",
        "Numbers",
        "Data Types",
        "Utilities"
      ],
      "languages": [
        "ruby",
        "python",
        "java",
        "csharp",
        "clojure",
        "haskell",
        "javascript",
        "coffeescript",
        "cpp",
        "php",
        "crystal",
        "c",
        "typescript",
        "rust",
        "swift",
        "r",
        "shell",
        "ocaml",
        "julia",
        "scala",
        "go",
        "nim",
        "racket",
        "fsharp",
        "kotlin",
        "groovy",
        "elixir"
      ]
    },
    {
      "id": "54eb33e5bc1a25440d000891",
      "name": "Square into Squares. Protect trees!",
      "description": "My little sister came back home from school with the following task:\ngiven a squared sheet of paper she has to cut it in pieces\nwhich, when assembled, give squares the sides of which form\nan increasing sequence of numbers.\nAt the beginning it was lot of fun but little by little we were tired of seeing the pile of torn paper.\nSo we decided to write a program that could help us and protects trees.\n\n## Task\n\nGiven a positive integral number n, return a **strictly increasing** sequence (list/array/string depending on the language) of numbers, so that the sum of the squares is equal to n².\n\nIf there are multiple solutions (and there will be), return as far as possible the result with the largest possible values:\n\n## Examples\n\n`decompose(11)` must return `[1,2,4,10]`. Note that there are actually two ways to decompose 11²,\n11² = 121 = 1 + 4 + 16 + 100 = 1² + 2² + 4² + 10² but don't return `[2,6,9]`, since 9 is smaller than 10.\n\nFor `decompose(50)` don't return `[1, 1, 4, 9, 49]` but `[1, 3, 5, 8, 49]` since `[1, 1, 4, 9, 49]`\ndoesn't form a strictly increasing sequence.\n\n## Note\nNeither `[n]` nor `[1,1,1,…,1]` are valid solutions. If no valid solution exists, return `nil`, `null`, `Nothing`, `None` (depending on the language) or `\"[]\"` (C) ,`{}` (C++), `[]` (Swift, Go).\n\nThe function \"decompose\" will take a positive integer n \nand return the decomposition of N = n² as:\n\n- [x1 ... xk]\nor\n- \"x1 ... xk\"\nor\n- Just [x1 ... xk]\nor\n- Some [x1 ... xk]\nor\n- {x1 ... xk}\nor\n- \"[x1,x2, ... ,xk]\"\n\ndepending on the language (see \"Sample tests\")\n\n# Note for Bash\n```\ndecompose 50 returns \"1,3,5,8,49\"\ndecompose 4  returns \"Nothing\"\n```\n# Hint\n\nVery often `xk` will be `n-1`.\n",
      "rank": -4,
      "rankName": "4 kyu",
      "tags": [
        "Fundamentals",
        "Mathematics",
        "Algorithms",
        "Logic",
        "Numbers",
        "Sequences",
        "Arrays",
        "Data Types"
      ],
      "languages": [
        "ruby",
        "java",
        "csharp",
        "python",
        "clojure",
        "haskell",
        "javascript",
        "coffeescript",
        "cpp",
        "php",
        "typescript",
        "rust",
        "swift",
        "c",
        "fsharp",
        "shell",
        "ocaml",
        "r",
        "crystal",
        "nasm",
        "julia",
        "scala",
        "go",
        "nim",
        "racket",
        "kotlin",
        "groovy",
        "fortran"
      ]
    },
    {
      "id": "54f5f22a00ecc4184c000034",
      "name": "Exponentials as fractions",
      "description": "The aim is to calculate `exponential(x)` (written `exp(x)` in most math libraries) as an irreducible fraction, the numerator of this fraction having a given number of digits.\n\nWe call this function `expand`, it takes two parameters, `x` of which we want to evaluate the exponential, `digits` which is the required number of digits for the numerator. \n\nThe function `expand` will return an array of the form `[numerator, denominator]`; we stop the loop in the Taylor expansion (see references below) when the numerator has a number of digits `>=` the required number of digits\n\n# Examples:\n```\nexpand(1, 2) --> 65/24 (we will write this [65, 24] or (65, 24) in Haskell; \n65/24 ~ 2.708...)\n\nexpand(2, 5) --> [20947, 2835]\n\nexpand(3, 10) --> [7205850259, 358758400]\n\nexpand(1.5, 10) --> [36185315027,8074035200]\n```\n**Note**\n```expand(1,5) = [109601, 40320]``` is the same as ```expand(1, 6)```\n\n#Method:\nAs said above the way here is to use `Taylor expansion` of the exponential function though it is not always the best approximation by a rational.\n\n#References:\nhttps://en.wikipedia.org/wiki/Exponential_function#Formal_definition\n\nhttp://www.efunda.com/math/taylor_series/exponential.cfm\n\n",
      "rank": -4,
      "rankName": "4 kyu",
      "tags": [
        "Fundamentals"
      ],
      "languages": [
        "ruby",
        "python",
        "haskell",
        "clojure",
        "r"
      ]
    },
    {
      "id": "54f8693ea58bce689100065f",
      "name": "Some Egyptian fractions",
      "description": "Given a rational number n\n\n``` n >= 0, with denominator strictly positive```  \n\n- as a string (example: \"2/3\" in Ruby, Python, Clojure, JS, CS, Go) \n- or as two strings (example: \"2\" \"3\" in Haskell, Java, CSharp, C++, Swift) \n- or as a rational or decimal number (example: 3/4, 0.67 in R) \n- or two integers (Fortran)\n\ndecompose \nthis number as a sum of rationals with numerators equal to one and without repetitions\n(2/3 = 1/2 + 1/6 is correct but not 2/3 = 1/3 + 1/3, 1/3 is repeated).\n    \nThe algorithm must be \"greedy\", so at each stage the new rational obtained in the decomposition must have a denominator as small as possible. \nIn this manner the sum of a few fractions in the decomposition gives a rather good approximation of the rational to decompose.\n    \n2/3 = 1/3 + 1/3 doesn't fit because of the repetition but also because the first 1/3 has a denominator bigger than the one in 1/2 \nin the decomposition 2/3 = 1/2 + 1/6.\n    \n### Example: \n(You can see other examples in \"Sample Tests:\")\n```\ndecompose(\"21/23\") or \"21\" \"23\" or 21/23 should return \n\n[\"1/2\", \"1/3\", \"1/13\", \"1/359\", \"1/644046\"] in Ruby, Python, Clojure, JS, CS, Haskell, Go\n\n\"[1/2, 1/3, 1/13, 1/359, 1/644046]\" in Java, CSharp, C++\n\n\"1/2,1/3,1/13,1/359,1/644046\" in C, Swift, R\n```  \n\n### Notes\n1) The decomposition of 21/23 as\n```\n21/23 = 1/2 + 1/3 + 1/13 + 1/598 + 1/897\n```\nis exact but don't fulfill our requirement because 598 is bigger than 359.\nSame for \n```\n21/23 = 1/2 + 1/3 + 1/23 + 1/46 + 1/69 (23 is bigger than 13)\nor \n21/23 = 1/2 + 1/3 + 1/15 + 1/110 + 1/253 (15 is bigger than 13).\n```\n    \n2) The rational given to decompose could be greater than one or equal to one, in which case the first \"fraction\" will be an integer \n(with an implicit denominator of 1). \n\n3) If the numerator parses to zero the function \"decompose\" returns [] (or \"\".\n\n4) The number could also be a decimal which can be expressed as a rational. \n\nexamples:\n\n`0.6` in Ruby, Python, Clojure,JS, CS, Julia, Go\n  \n`\"66\" \"100\"` in Haskell, Java, CSharp, C++, C, Swift, Scala, Kotlin\n\n`0.67` in R.\n\n**Ref:**\nhttp://en.wikipedia.org/wiki/Egyptian_fraction\n\n\n\n\n\n\n\n",
      "rank": -5,
      "rankName": "5 kyu",
      "tags": [
        "Fundamentals"
      ],
      "languages": [
        "ruby",
        "python",
        "clojure",
        "haskell",
        "javascript",
        "coffeescript",
        "java",
        "csharp",
        "elixir",
        "typescript",
        "cpp",
        "php",
        "crystal",
        "c",
        "swift",
        "r",
        "julia",
        "scala",
        "go",
        "nim",
        "racket",
        "fsharp",
        "vb",
        "kotlin",
        "groovy",
        "fortran",
        "rust"
      ]
    },
    {
      "id": "550498447451fbbd7600041c",
      "name": "Are they the \"same\"?",
      "description": "Given two arrays `a` and `b` write a function `comp(a, b)` (`compSame(a, b)` in Clojure) that checks whether the two arrays have the \"same\" elements, with the same multiplicities. \"Same\" means, here, that the elements in `b` are the elements in `a` squared, regardless of the order.\n\n## Examples\n## Valid arrays\n```\na = [121, 144, 19, 161, 19, 144, 19, 11]  \nb = [121, 14641, 20736, 361, 25921, 361, 20736, 361]\n```\n`comp(a, b)` returns true because in `b` 121 is the square of 11, 14641 is the square of 121, 20736 the square of 144, 361 the square of 19, 25921 the square of 161, and so on. It gets obvious if we write `b`'s elements in terms of squares:\n```\na = [121, 144, 19, 161, 19, 144, 19, 11] \nb = [11*11, 121*121, 144*144, 19*19, 161*161, 19*19, 144*144, 19*19]\n```\n### Invalid arrays\nIf we change the first number to something else, `comp` may not return true anymore:\n```\na = [121, 144, 19, 161, 19, 144, 19, 11]  \nb = [132, 14641, 20736, 361, 25921, 361, 20736, 361]\n```\n`comp(a,b)` returns false because in `b` 132 is not the square of any number of `a`.\n```\na = [121, 144, 19, 161, 19, 144, 19, 11]  \nb = [121, 14641, 20736, 36100, 25921, 361, 20736, 361]\n```\n`comp(a,b)` returns false because in `b` 36100 is not the square of any number of `a`.\n\n## Remarks\n- `a` or `b` might be `[]` (all languages except R, Shell).\n- `a` or `b` might be `nil` or `null` or `None` or `nothing` (except in Haskell, Elixir, C++, Rust, R, Shell, PureScript). \n\nIf `a` or `b` are `nil` (or `null` or `None`), the problem doesn't make sense so return false.\n\n#### Note for C\nThe two arrays have the same size `(> 0)` given as parameter in function `comp`.\n",
      "rank": -6,
      "rankName": "6 kyu",
      "tags": [
        "Fundamentals"
      ],
      "languages": [
        "ruby",
        "csharp",
        "python",
        "java",
        "clojure",
        "haskell",
        "javascript",
        "coffeescript",
        "elixir",
        "typescript",
        "cpp",
        "php",
        "crystal",
        "fsharp",
        "c",
        "rust",
        "swift",
        "r",
        "scala",
        "shell",
        "ocaml",
        "julia",
        "kotlin",
        "powershell",
        "go",
        "nim",
        "purescript",
        "nasm",
        "racket",
        "groovy",
        "prolog",
        "cfml",
        "fortran",
        "haxe"
      ]
    },
    {
      "id": "55031bba8cba40ada90011c4",
      "name": "Hidden \"Cubic\" numbers",
      "description": "We search non-negative integer numbers, with at **most** 3 digits, such as the sum of the cubes of their digits is the number itself; we will call them \"cubic\" numbers.\n```\n153 is such a \"cubic\" number : 1^3 + 5^3 + 3^3 = 153\n```\nThese \"cubic\" numbers of at most 3 digits are easy to find, even by hand, so they are \"hidden\" with other numbers and characters in a string. \n\nThe task is to find, or not, the \"cubic\" numbers in the string and then to make the sum of these \"cubic\" numbers found in the string, if any, and to return a string such as:\n```\n\"number1 number2 (and so on if necessary) sumOfCubicNumbers Lucky\" \n``` \n if \"cubic\" numbers number1, number2, ... were found. The numbers in the output are to be in the order in which they are encountered in the input string.\n \n If no cubic numbers are found return the string:\n``` \n\"Unlucky\".\n``` \n\nExamples:\n```\n s = \"aqdf& 0 1 xyz 153 777.777\" must return \"0 1 153 154 Lucky\"\n\n s = \"QK29 45[&erui\" must return \"Unlucky\".\n``` \n \n **Note:**\nIn the string \"001234\" where 3 digits or more follow each other the first packet to examine is \"001\" and the following is \"234\". If a packet of at most three digits has been taken, whether or not \"cubic\", it's over for that packet. \n\nWhen a continuous string of digits exceeds 3, the string is split into groups of 3 from the left. The last grouping could have 3, 2 or 1 digits.\ne.g \"24172410\" becomes 3 strings comprising \"241\", \"724\" and \"10\"\ne.g \"0785\" becomes 2 strings comprising \"078\" and \"5\".",
      "rank": -6,
      "rankName": "6 kyu",
      "tags": [
        "Fundamentals"
      ],
      "languages": [
        "java",
        "csharp",
        "python",
        "javascript",
        "ruby",
        "haskell",
        "coffeescript",
        "clojure",
        "cpp",
        "php",
        "crystal",
        "c",
        "typescript",
        "swift",
        "r",
        "shell",
        "fsharp",
        "julia",
        "scala",
        "go",
        "nim",
        "rust",
        "racket",
        "kotlin",
        "groovy"
      ]
    },
    {
      "id": "550527b108b86f700000073f",
      "name": "PI approximation ",
      "description": "The aim of the kata is to try to show how difficult it can be to calculate decimals of an irrational number with a certain precision. We have chosen to get a few decimals of the number \"pi\" using\nthe following infinite series (Leibniz 1646–1716): \n\nPI / 4 = 1 - 1/3 + 1/5 - 1/7 + ... which gives an approximation of PI / 4.\n\nhttp://en.wikipedia.org/wiki/Leibniz_formula_for_%CF%80\n\nTo have a measure of the difficulty we will count how many iterations are needed to calculate PI with a given precision. \n\nThere are several ways to determine the precision of the calculus but to keep things easy we will calculate to within epsilon of your language Math::PI constant. In other words we will stop  the iterative process when the absolute value of the difference between our calculation and the Math::PI constant of the given language is less than epsilon.\n\nYour function returns an array or an arrayList or a string or a tuple depending on the language (See sample tests) where your approximation of PI has 10 decimals \n\nIn Haskell you can use the function \"trunc10Dble\" (see \"Your solution\"); in Clojure you can use the function \"round\" (see \"Your solution\");in OCaml or Rust the function \"rnd10\" (see \"Your solution\") in order to avoid discussions about the result.\n\nExample :\n```\nyour function calculates 1000 iterations and 3.140592653839794 but returns:\niter_pi(0.001) --> [1000, 3.1405926538]\n```\n\nUnfortunately, this series converges too slowly to be useful, \nas it takes over 300 terms to obtain a 2 decimal place precision. \nTo obtain 100 decimal places of PI, it was calculated that\none would need to use at least 10^50 terms of this expansion!\n\nAbout PI : http://www.geom.uiuc.edu/~huberty/math5337/groupe/expresspi.html",
      "rank": -6,
      "rankName": "6 kyu",
      "tags": [
        "Fundamentals",
        "Arrays",
        "Data Types",
        "Mathematics",
        "Algorithms",
        "Logic",
        "Numbers"
      ],
      "languages": [
        "ruby",
        "csharp",
        "haskell",
        "java",
        "python",
        "javascript",
        "coffeescript",
        "clojure",
        "elixir",
        "typescript",
        "cpp",
        "php",
        "crystal",
        "fsharp",
        "c",
        "ocaml",
        "rust",
        "swift",
        "go",
        "r",
        "shell",
        "julia",
        "scala",
        "powershell",
        "nim",
        "racket",
        "forth",
        "kotlin",
        "groovy",
        "fortran"
      ]
    },
    {
      "id": "550554fd08b86f84fe000a58",
      "name": "Which are  in?",
      "description": "Given two arrays of strings `a1` and `a2` return a sorted array `r` in lexicographical order of the strings of `a1` which are substrings of strings of `a2`.\n\n#Example 1:\n`a1 = [\"arp\", \"live\", \"strong\"]`\n\n`a2 = [\"lively\", \"alive\", \"harp\", \"sharp\", \"armstrong\"]`\n\nreturns `[\"arp\", \"live\", \"strong\"]`\n\n#Example 2:\n`a1 = [\"tarp\", \"mice\", \"bull\"]`\n\n`a2 = [\"lively\", \"alive\", \"harp\", \"sharp\", \"armstrong\"]`\n\nreturns `[]`\n\n# Notes: \n- Arrays are written in \"general\" notation. See \"Your Test Cases\" for examples in your language.\n\n- In Shell bash `a1` and `a2` are strings. The return is a string where words are separated by commas.\n\n\n- Beware: `r` must be without duplicates.\n- Don't mutate the inputs.",
      "rank": -6,
      "rankName": "6 kyu",
      "tags": [
        "Refactoring",
        "Arrays",
        "Data Types",
        "Search",
        "Algorithms",
        "Logic",
        "Lists",
        "Data Structures",
        "Strings"
      ],
      "languages": [
        "ruby",
        "csharp",
        "python",
        "java",
        "clojure",
        "haskell",
        "javascript",
        "coffeescript",
        "elixir",
        "typescript",
        "cpp",
        "php",
        "crystal",
        "fsharp",
        "c",
        "swift",
        "r",
        "shell",
        "ocaml",
        "julia",
        "scala",
        "powershell",
        "kotlin",
        "go",
        "nim",
        "racket"
      ]
    },
    {
      "id": "55084d3898b323f0aa000546",
      "name": "Second Variation on Caesar Cipher",
      "description": "In this country soldiers are poor but they need a certain level of secrecy\nfor their communications so, though they do not know Caesar cypher, they reinvent it\nin the following way.\n\nThey use ASCII, without really knowing it, but code only letters a-z and A-Z. Other \ncharacters are kept such as.\n\nThey change the \"rotate\" each new message. This \"rotate\" is a prefix for their message\nonce the message is coded. The prefix is built of 2 letters, the second one being shifted \nfrom the first one by the \"rotate\", the first one is the first letter, after being downcased,\nof the uncoded message.\n\nFor example if the \"rotate\" is 2, if the first letter of the uncoded message is 'J' \nthe prefix should be 'jl'.\n\nTo lessen risk they cut the coded message and the prefix in five pieces since they\nhave only five runners and each runner has only one piece. \n\nIf possible\nthe message will be evenly split between the five runners; if not possible, parts 1, 2, 3, 4 will be longer and part 5 shorter. The fifth part can have length equal to the other ones or shorter. If there are many options of how to split, choose the option where the fifth part has the longest length, provided that the previous conditions are fulfilled. *If the last part is the empty string don't put this empty string in the resulting array.*\n\nFor example, if the coded message has a length of 17 the five parts will have lengths of 4, 4, 4, 4, 1. The parts 1, 2, 3, 4 are evenly split and the last part of length 1 is shorter. If the length is 16 the parts will be of lengths 4, 4, 4, 4, 0. Parts 1, 2, 3, 4 are evenly split and the fifth runner will stay at home since his part is the empty string and is not kept.\n\nCould you ease them in programming their coding?\n\nExample with shift = 1 :\n\nmessage : \"I should have known that you would have a perfect answer for me!!!\"\n\ncode : => [\"ijJ tipvme ibw\", \"f lopxo uibu z\", \"pv xpvme ibwf \", \"b qfsgfdu botx\", \"fs gps nf!!!\"]\n\nBy the way, maybe could you give them a hand to decode?\n\nCaesar cipher : see Wikipedia\n",
      "rank": -5,
      "rankName": "5 kyu",
      "tags": [
        "Fundamentals"
      ],
      "languages": [
        "ruby",
        "python",
        "java",
        "javascript",
        "coffeescript",
        "csharp",
        "haskell",
        "clojure",
        "cpp",
        "php",
        "c",
        "typescript",
        "swift",
        "crystal",
        "r",
        "ocaml",
        "go",
        "fsharp",
        "scala"
      ]
    },
    {
      "id": "5508249a98b3234f420000fb",
      "name": "First Variation on Caesar Cipher",
      "description": "The action of a Caesar cipher is to replace each plaintext letter with a different one a fixed number of places up or down the alphabet.\n\nThis program performs a variation of the Caesar shift. The shift increases by 1 for each character (on each iteration).\n\nIf the shift is initially 1, the first character of the message to be\nencoded will be shifted by 1, the second character will be\nshifted by 2, etc...\n\n# Coding: Parameters and return of function \"movingShift\"\n\nparam s: a string to be coded\n\nparam shift: an integer giving the initial shift\n\nThe function \"movingShift\" *first* codes the entire string and *then* returns an array of strings \ncontaining the coded string in 5 parts (five parts\nbecause, to avoid more risks, the coded message will be given to five\nrunners, one piece for each runner). \n\nIf possible the message will be equally divided by message length between the five runners. If this is not possible, parts 1 to 5 will have subsequently non-increasing lengths, such that parts 1 to 4 are at least as long as when evenly divided, but at most 1 longer. If the last part is the empty string this empty string must be shown in the resulting array.\n\nFor example, if the coded message has a length of 17 the five parts will have lengths of 4, 4, 4, 4, 1. The parts 1, 2, 3, 4 are evenly split and the last part of length 1 is shorter. If the length is 16 the parts will be of lengths 4, 4, 4, 4, 0. Parts 1, 2, 3, 4 are evenly split and the fifth runner will stay at home since his part is the empty string. If the length is 11, equal parts would be of length 2.2, hence parts will be of lengths 3, 3, 3, 2, 0.\n\nYou will also implement a \"demovingShift\" function with two parameters \n\n# Decoding: parameters and return of function \"demovingShift\"\n\n1) an array of strings: s (possibly resulting from \"movingShift\", with 5 strings)\n\n2) an int shift\n\n\"demovingShift\" returns a string.\n\n# Example: \n\nu = \"I should have known that you would have a perfect answer for me!!!\"\n\n`movingShift(u, 1)` returns : \n\nv = [\"J vltasl rlhr \", \"zdfog odxr ypw\", \" atasl rlhr p \", \"gwkzzyq zntyhv\", \" lvz wp!!!\"]\n\n(quotes added in order to see the strings and the spaces, your program won't write these quotes, see Example Test Cases)\n\nand `demovingShift(v, 1)` returns u.\n#Ref:\n\nCaesar Cipher : http://en.wikipedia.org/wiki/Caesar_cipher\n",
      "rank": -5,
      "rankName": "5 kyu",
      "tags": [
        "Fundamentals",
        "Ciphers",
        "Algorithms",
        "Cryptography",
        "Logic",
        "Security",
        "Strings",
        "Data Types",
        "Utilities"
      ],
      "languages": [
        "java",
        "csharp",
        "ruby",
        "python",
        "javascript",
        "coffeescript",
        "clojure",
        "haskell",
        "cpp",
        "php",
        "c",
        "typescript",
        "swift",
        "crystal",
        "r",
        "shell",
        "ocaml",
        "go",
        "nim",
        "racket",
        "fsharp",
        "scala",
        "fortran"
      ]
    },
    {
      "id": "5506b230a11c0aeab3000c1f",
      "name": "Deodorant Evaporator",
      "description": "This program tests the life of an\nevaporator containing a gas. \n\nWe know the content of the evaporator (content in ml),\nthe percentage of foam or gas lost every day (evap_per_day)\nand the threshold (threshold) in percentage beyond which\nthe evaporator is no longer useful.\nAll numbers are strictly positive.\n\nThe program reports the nth day (as an integer)\non which the evaporator will be out of use.\n\n**Note** : Content is in fact not necessary in the body of the function \"evaporator\", you can use it or not use it, as you wish. Some people might prefer to reason with content, some other with percentages only. It's up to you but you must keep it as a parameter because the tests have it as an argument.",
      "rank": -7,
      "rankName": "7 kyu",
      "tags": [
        "Fundamentals"
      ],
      "languages": [
        "ruby",
        "python",
        "java",
        "csharp",
        "clojure",
        "javascript",
        "haskell",
        "coffeescript",
        "elixir",
        "typescript",
        "cpp",
        "php",
        "crystal",
        "fsharp",
        "c",
        "r",
        "shell",
        "ocaml",
        "fortran",
        "julia",
        "scala",
        "powershell",
        "kotlin",
        "go",
        "nim",
        "rust",
        "racket",
        "dart",
        "forth",
        "haxe"
      ]
    },
    {
      "id": "550f22f4d758534c1100025a",
      "name": "Directions Reduction",
      "description": "### Once upon a time, on a way through the old wild mountainous west,…\n\n… a man was given directions to go from one point to another. The directions were \"NORTH\", \"SOUTH\", \"WEST\", \"EAST\". Clearly \"NORTH\" and \"SOUTH\" are opposite, \"WEST\" and \"EAST\" too. \n\nGoing to one direction and coming back the opposite direction *right away* is a needless effort. Since this is the wild west, with dreadfull weather and not much water, it's important to save yourself some energy, otherwise you might die of thirst!\n\n### How I crossed a *mountain* desert the smart way.\n\nThe directions given to the man are, for example, the following (depending on the language):\n\n```\n[\"NORTH\", \"SOUTH\", \"SOUTH\", \"EAST\", \"WEST\", \"NORTH\", \"WEST\"].\n```\n\nor\n\n```\n{ \"NORTH\", \"SOUTH\", \"SOUTH\", \"EAST\", \"WEST\", \"NORTH\", \"WEST\" };\n```\n\nor\n\n```\n[North, South, South, East, West, North, West]\n```\n\nYou can immediatly see that going \"NORTH\" and *immediately* \"SOUTH\" is not reasonable, better stay to the same place!\nSo the task is to give to the man a simplified version of the plan. A better plan in this case is simply:\n\n```\n[\"WEST\"]\n```\n\nor\n\n```\n{ \"WEST\" }\n```\n\nor\n\n```\n[West]\n```\n\n### Other examples:\n\nIn `[\"NORTH\", \"SOUTH\", \"EAST\", \"WEST\"]`, the direction `\"NORTH\" + \"SOUTH\"` is going north and coming back *right away*. \n\nThe path becomes `[\"EAST\", \"WEST\"]`, now `\"EAST\"` and `\"WEST\"` annihilate each other, therefore, the final result is `[]` (nil in Clojure).\n\nIn [\"NORTH\", \"EAST\", \"WEST\", \"SOUTH\", \"WEST\", \"WEST\"], \"NORTH\" and \"SOUTH\" are *not* directly opposite but they become directly opposite after the reduction of \"EAST\" and \"WEST\" so the whole path is reducible to [\"WEST\", \"WEST\"].\n\n### Task\n\nWrite a function `dirReduc` which will take an array of strings and returns an array of strings with the needless directions removed (W<->E or S<->N *side by side*).\n\n- The Haskell version takes a list of directions with `data Direction = North | East | West | South`. \n-The Clojure version returns nil when the path is reduced to nothing. \n-The Rust version takes a slice of `enum Direction {NORTH, SOUTH, EAST, WEST}`.\n\n### See more examples in \"Sample Tests:\"\n\n## Notes\n\n- Not all paths can be made simpler. \nThe path [\"NORTH\", \"WEST\", \"SOUTH\", \"EAST\"] is not reducible. \"NORTH\" and \"WEST\", \"WEST\" and \"SOUTH\", \"SOUTH\" and \"EAST\" are not *directly* opposite of each other and can't become such. Hence the result path is itself : [\"NORTH\", \"WEST\", \"SOUTH\", \"EAST\"].\n\n\n- if you want to translate, please ask before translating.\n",
      "rank": -5,
      "rankName": "5 kyu",
      "tags": [
        "Fundamentals"
      ],
      "languages": [
        "ruby",
        "javascript",
        "haskell",
        "python",
        "java",
        "coffeescript",
        "csharp",
        "clojure",
        "cpp",
        "php",
        "crystal",
        "fsharp",
        "rust",
        "c",
        "typescript",
        "swift",
        "shell",
        "r",
        "objc",
        "ocaml",
        "elixir",
        "lua",
        "julia",
        "scala",
        "powershell",
        "go",
        "nim",
        "racket",
        "reason",
        "kotlin",
        "prolog",
        "haxe"
      ]
    },
    {
      "id": "5517fcb0236c8826940003c9",
      "name": "Irreducible Sum of Rationals",
      "description": "You will have a list of rationals in the form\n\n```\nlst = [ [numer_1, denom_1] , ... , [numer_n, denom_n] ]\n```\nor\n```\nlst = [ (numer_1, denom_1) , ... , (numer_n, denom_n) ]\n```\n\nwhere all numbers are positive integers. You have to produce their sum `N / D` in an irreducible form: this means that `N` and `D` have only `1` as a common divisor.\n\nReturn the result in the form:\n\n- `[N, D]` in Ruby, Crystal, Python, Clojure, JS, CS, PHP, Julia\n- `Just \"N D\"` in Haskell, PureScript\n- `\"[N, D]\"` in Java, CSharp, TS, Scala, PowerShell, Kotlin\n- `\"N/D\"` in Go, Nim\n- `{N, D}` in C++, Elixir\n- `{N, D}` in C\n- `Some((N, D))` in Rust\n- `Some \"N D\"` in F#, Ocaml\n- `c(N, D)` in R\n- `(N, D)` in Swift\n- `'(N D)` in Racket\n\nIf the result is an integer (`D` evenly divides `N`) return:\n\n- an integer in Ruby, Crystal, Elixir, Clojure, Python, JS, CS, PHP, R, Julia\n- `Just \"n\"` (Haskell, PureScript)\n- `\"n\"` Java, CSharp, TS, Scala, PowerShell, Go, Nim, Kotlin\n- `{n, 1}` in C++\n- `{n, 1}` in C\n- `Some((n, 1))` in Rust\n- `Some \"n\"` in F#, Ocaml,\n- `(n, 1)` in Swift\n- `n` in Racket \n\nIf the input list is empty, return \n\n- `nil/None/null/Nothing` \n- `{0, 1}` in C++\n- `{0, 1}` in C\n- `\"0\"` in Scala, PowerShell, Go, Nim\n- `O` in Racket\n- `\"\"` in Kotlin\n\n\n### Example:\n\n```\n[ [1, 2], [1, 3], [1, 4] ]  -->  [13, 12]\n\n    1/2  +  1/3  +  1/4     =      13/12\n```\n\n### Note\nSee sample tests for more examples and the form of results.\n",
      "rank": -6,
      "rankName": "6 kyu",
      "tags": [
        "Fundamentals"
      ],
      "languages": [
        "ruby",
        "haskell",
        "python",
        "clojure",
        "javascript",
        "coffeescript",
        "java",
        "csharp",
        "typescript",
        "cpp",
        "elixir",
        "php",
        "crystal",
        "fsharp",
        "c",
        "rust",
        "swift",
        "r",
        "ocaml",
        "julia",
        "scala",
        "powershell",
        "go",
        "nim",
        "purescript",
        "racket",
        "kotlin",
        "prolog"
      ]
    },
    {
      "id": "5539fecef69c483c5a000015",
      "name": "Backwards Read Primes",
      "description": "Backwards Read Primes are primes that when read backwards in base 10 (from right to left) \r\nare a different prime. (This rules out primes which are palindromes.)\r\n```\r\nExamples:\r\n13 17 31 37 71 73 are Backwards Read Primes\r\n```\r\n13 is such because it's prime and read from right to left writes 31 which is prime too. Same for the others.\r\n\r\n## Task\r\nFind all Backwards Read Primes between two positive given numbers (both inclusive), the second one always being greater than or equal to the first one. The resulting array or the resulting string will be ordered following the natural order of the prime numbers.\r\n\r\n## Example\r\n\r\nbackwardsPrime(2, 100) => [13, 17, 31, 37, 71, 73, 79, 97] \r\nbackwardsPrime(9900, 10000) => [9923, 9931, 9941, 9967]\r\nbackwardsPrime(501, 599) => []\r\n\r\n## Note for Forth\r\nReturn only the first backwards-read prime between start and end\r\nor 0 if you don't find any\r\n\r\n```ruby\r\nDon't use Ruby Prime class, it's disabled.\r\nbackwardsPrime(2, 100) => [13, 17, 31, 37, 71, 73, 79, 97] \r\nbackwardsPrime(9900, 10000) => [9923, 9931, 9941, 9967]\r\n```\r\n```crystal\r\nbackwardsPrime(2, 100) => [13, 17, 31, 37, 71, 73, 79, 97] \r\nbackwardsPrime(9900, 10000) => [9923, 9931, 9941, 9967]\r\n```\r\n```python\r\nbackwards_prime(2, 100) => [13, 17, 31, 37, 71, 73, 79, 97] \r\nbackwards_prime(9900, 10000) => [9923, 9931, 9941, 9967]\r\n```\r\n```java\r\nbackwardsPrime(2, 100) => \"13 17 31 37 71 73 79 97\"\r\nbackwardsPrime(9900, 10000) => \"9923 9931 9941 9967\"\r\n```\r\n```csharp\r\nbackwardsPrime(2, 100) => \"13 17 31 37 71 73 79 97\"\r\nbackwardsPrime(9900, 10000) => \"9923 9931 9941 9967\"\r\n```\r\n```fsharp\r\nbackwardsPrime(2, 100) => [13, 17, 31, 37, 71, 73, 79, 97] \r\nbackwardsPrime(9900, 10000) => [9923, 9931, 9941, 9967]\r\n```\r\n```clojure\r\n(backwards-prime 2 100) => [13, 17, 31, 37, 71, 73, 79, 97] \r\n(backwards-prime 9900 10000) => [9923, 9931, 9941, 9967]\r\n```\r\n```haskell\r\nbackwards-prime 2 100 shouldBe [13, 17, 31, 37, 71, 73, 79, 97] \r\nbackwards-prime 9900 10000 shouldBe [9923, 9931, 9941, 9967]\r\n```\r\n```javascript\r\nbackwardsPrime(2, 100) => [13, 17, 31, 37, 71, 73, 79, 97] \r\nbackwardsPrime(9900, 10000) => [9923, 9931, 9941, 9967]\r\n```\r\n```typescript\r\nbackwardsPrime(2, 100) => [13, 17, 31, 37, 71, 73, 79, 97] \r\nbackwardsPrime(9900, 10000) => [9923, 9931, 9941, 9967]\r\n```\r\n```coffeescript\r\nbackwardsPrime(2, 100) => [13, 17, 31, 37, 71, 73, 79, 97] \r\nbackwardsPrime(9900, 10000) => [9923, 9931, 9941, 9967]\r\n```\r\n```php\r\nbackwardsPrime(2, 100) => [13, 17, 31, 37, 71, 73, 79, 97] \r\nbackwardsPrime(9900, 10000) => [9923, 9931, 9941, 9967]\r\n```\r\n```cpp\r\nbackwardsPrime(2, 100) => \"13 17 31 37 71 73 79 97\"\r\nbackwardsPrime(9900, 10000) => \"9923 9931 9941 9967\"\r\n```\r\n```c\r\nC returns a structure. See \"Solution\" and \"Examples\" tabs\r\n```\r\n```nasm\r\nsize_t size;\r\nint *a = backwards_prime(2, 100, &size); // => {13, 17, 31, 37, 71, 73, 79, 97}\r\nprintf(\"%lld\\n\", size); // > 8\r\nfree(a);\r\na = backwards_prime(9900, 10000, &size); // => {9923, 9931, 9941, 9967}\r\nprintf(\"%lld\\n\", size); // > 4\r\nfree(a);\r\n```\r\n```rust\r\nbackwardsPrime(2, 100) => [13, 17, 31, 37, 71, 73, 79, 97] \r\nbackwardsPrime(9900, 10000) => [9923, 9931, 9941, 9967]\r\n```\r\n```swift\r\nbackwardsPrime(2, 100) => [13, 17, 31, 37, 71, 73, 79, 97] \r\nbackwardsPrime(9900, 10000) => [9923, 9931, 9941, 9967]\r\n```\r\n```r\r\nbackwardsPrime(2, 100) => c(13, 17, 31, 37, 71, 73, 79, 97)\r\nbackwardsPrime(9900, 10000) => c(9923, 9931, 9941, 9967)\r\n```\r\n```elixir\r\nbackwardsPrime(2, 100) => [13, 17, 31, 37, 71, 73, 79, 97] \r\nbackwardsPrime(9900, 10000) => [9923, 9931, 9941, 9967]\r\n```\r\n\r\n",
      "rank": -6,
      "rankName": "6 kyu",
      "tags": [
        "Algorithms",
        "Mathematics",
        "Logic",
        "Numbers"
      ],
      "languages": [
        "ruby",
        "python",
        "clojure",
        "haskell",
        "javascript",
        "csharp",
        "java",
        "coffeescript",
        "cpp",
        "php",
        "crystal",
        "fsharp",
        "c",
        "typescript",
        "rust",
        "swift",
        "r",
        "shell",
        "ocaml",
        "scala",
        "kotlin",
        "elixir",
        "nasm",
        "julia",
        "powershell",
        "go",
        "nim",
        "racket",
        "forth",
        "prolog",
        "fortran"
      ]
    },
    {
      "id": "5536a85b6ed4ee5a78000035",
      "name": "Help your granny!",
      "description": "Your granny, who lives in town X0, has friends. \nThese friends are given in an array, for example: \narray of friends is \n```\n[ \"A1\", \"A2\", \"A3\", \"A4\", \"A5\" ].\n```\n**The order of friends is this array must *not be changed* since this order gives the order in which they will be visited.**\n\nThese friends inhabit towns and you have an array\nwith friends and towns, for example:\n```\n[ [\"A1\", \"X1\"], [\"A2\", \"X2\"], [\"A3\", \"X3\"], [\"A4\", \"X4\"] ]\nor\n[ (\"A1\", \"X1\"), (\"A2\", \"X2\"), (\"A3\", \"X3\"), (\"A4\", \"X4\") ]\nor\n(C)\n{\"A1\", \"X1\", \"A2\", \"X2\", \"A3\", \"X3\", \"A4\", \"X4\"}\n```\nwhich means A1 is in town X1, A2 in town X2...\nIt can happen that we don't know the town of one of the friends.\n \nYour granny wants to visit her friends and to know how many miles\nshe will have to travel.\n \nYou will make the circuit that permits her to visit her friends.\nFor example here the circuit will contain: \n```\nX0, X1, X2, X3, X4, X0 \n```\nand you must compute the total distance \n```\nX0X1 + X1X2 + .. + X4X0.\n```\nFor the distance, fortunately, you have a map (and a hashmap) that gives each distance X0X1, X0X2 and so on. For example:\n```\n[ [\"X1\", 100.0], [\"X2\", 200.0], [\"X3\", 250.0], [\"X4\", 300.0] ]\nor\nMap(\"X1\" -> 100.0, \"X2\" -> 200.0, \"X3\" -> 250.0, \"X4\" -> 300.0)\nor (Coffeescript, Javascript)\n['X1',100.0, 'X2',200.0, 'X3',250.0, 'X4',300.0 ]\nor\n(C)\n{\"X1\", \"100.0\", \"X2\", \"200.0\", \"X3\", \"250.0\", \"X4\", \"300.0\"}\n```\nwhich means that X1 is at 100.0 miles from X0, X2 at 200.0 miles from X0, etc...\n\nMore fortunately (it's not real life, it's a story...), \nthe towns X0, X1, ..Xn are placed in the following manner:\n\nX0X1X2 is a right triangle with the right angle in X1, X0X2X3 \nis a right triangle with the right angle in X2, etc...\n \nIf a town Xi is not visited you will suppose that the triangle \n\n<code> X<sub>0</sub>X<sub>i-1</sub>X<sub>i+1</sub> </code> is still a right triangle.\n \n(Ref: https://en.wikipedia.org/wiki/Pythagoras#Pythagorean_theorem)\n\n# Task\nCan you help your granny and give her the distance to travel?\n\n# Notes\nIf you have some difficulty to see the tour I made a non terrific but maybe useful drawing:\n\n![alternative text](http://i.imgur.com/dG7iWXhm.jpg)\n\n## All languages\nSee the data type of the parameters in the examples test cases.\n\nTowns can have other names that `X0, X1, X2, ... Xn`\n\n\"tour\" returns an int which is the floor of the total distance.\n",
      "rank": -5,
      "rankName": "5 kyu",
      "tags": [
        "Fundamentals",
        "Mathematics",
        "Algorithms",
        "Logic",
        "Numbers"
      ],
      "languages": [
        "csharp",
        "python",
        "java",
        "ruby",
        "haskell",
        "clojure",
        "javascript",
        "coffeescript",
        "cpp",
        "php",
        "crystal",
        "c",
        "typescript",
        "rust",
        "swift",
        "fsharp",
        "shell",
        "ocaml",
        "julia",
        "scala",
        "go",
        "racket",
        "kotlin"
      ]
    },
    {
      "id": "5541f58a944b85ce6d00006a",
      "name": "Product of consecutive Fib numbers",
      "description": "The Fibonacci numbers are the numbers in the following integer sequence (Fn):\n>0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, ...\n\nsuch as \n>F(n) = F(n-1) + F(n-2) with F(0) = 0 and F(1) = 1.\n\nGiven a number, say prod (for product), we search two Fibonacci numbers F(n) and F(n+1) verifying \n>F(n) * F(n+1) = prod.\n\nYour function productFib takes an integer (prod) and returns\nan array: \n```\n[F(n), F(n+1), true] or {F(n), F(n+1), 1} or (F(n), F(n+1), True)\n```\ndepending on the language if F(n) * F(n+1) = prod.\n\nIf you don't find two consecutive F(m) verifying `F(m) * F(m+1) = prod`you will return\n```\n[F(m), F(m+1), false] or {F(n), F(n+1), 0} or (F(n), F(n+1), False)\n```\nF(m) being the smallest one such as `F(m) * F(m+1) > prod`.\n\n\n### Some Examples of Return:\n(depend on the language)\n\n```\nproductFib(714) # should return (21, 34, true), \n                # since F(8) = 21, F(9) = 34 and 714 = 21 * 34\n\nproductFib(800) # should return (34, 55, false), \n                # since F(8) = 21, F(9) = 34, F(10) = 55 and 21 * 34 < 800 < 34 * 55\n-----\nproductFib(714) # should return [21, 34, true], \nproductFib(800) # should return [34, 55, false], \n-----\nproductFib(714) # should return {21, 34, 1}, \nproductFib(800) # should return {34, 55, 0},        \n-----\nproductFib(714) # should return {21, 34, true}, \nproductFib(800) # should return {34, 55, false}, \n```\n\n### Note:\n\n- You can see examples for your language in \"Sample Tests\".\n\n",
      "rank": -5,
      "rankName": "5 kyu",
      "tags": [
        "Fundamentals"
      ],
      "languages": [
        "ruby",
        "javascript",
        "csharp",
        "haskell",
        "python",
        "java",
        "clojure",
        "coffeescript",
        "cpp",
        "php",
        "crystal",
        "fsharp",
        "c",
        "typescript",
        "rust",
        "swift",
        "go",
        "r",
        "shell",
        "ocaml",
        "kotlin",
        "elixir",
        "julia",
        "scala",
        "powershell",
        "nim",
        "racket",
        "reason",
        "forth",
        "prolog",
        "fortran"
      ]
    },
    {
      "id": "5544c7a5cb454edb3c000047",
      "name": "Bouncing Balls",
      "description": "A child is playing with a ball on the nth floor of a tall building.\nThe height of this floor, *h*, is known. \n\nHe drops the ball out of the window. The ball bounces (for example), to two-thirds of its height (a bounce of 0.66).\n \nHis mother looks out of a window 1.5 meters from the ground.\n\nHow many times will the mother see the ball pass in front of her window (including when it's falling _and_ bouncing?\n\n## Three conditions must be met for a valid experiment:\n\n*  Float parameter \"h\" in meters must be greater than 0\n*  Float parameter \"bounce\" must be greater than 0 and less than 1\n*  Float parameter \"window\" must be less than h.\n\n**If all three conditions above are fulfilled, return a positive integer, otherwise return -1.**\n\n### Note:\nThe ball can only be seen if the height of the rebounding ball is strictly greater than the window parameter.\n\n### Example:\n```\n- h = 3, bounce = 0.66, window = 1.5, result is 3\n\n- h = 3, bounce = 1, window = 1.5, result is -1 \n\n(Condition 2) not fulfilled).\n```",
      "rank": -6,
      "rankName": "6 kyu",
      "tags": [
        "Fundamentals"
      ],
      "languages": [
        "ruby",
        "python",
        "clojure",
        "java",
        "csharp",
        "javascript",
        "haskell",
        "coffeescript",
        "typescript",
        "cpp",
        "elixir",
        "php",
        "crystal",
        "fsharp",
        "c",
        "rust",
        "swift",
        "go",
        "r",
        "shell",
        "ocaml",
        "kotlin",
        "fortran",
        "julia",
        "scala",
        "powershell",
        "nim",
        "racket",
        "reason",
        "prolog"
      ]
    },
    {
      "id": "55466989aeecab5aac00003e",
      "name": "Rectangle into Squares",
      "description": "The drawing below gives an idea of how to cut a given \"true\" rectangle into squares (\"true\" rectangle meaning that the two dimensions are different).\n\n![alternative text](https://i.imgur.com/lk5vJ7sm.jpg)\n\nCan you translate this drawing into an algorithm?\n\nYou will be given two dimensions \n\n1. a positive integer length (parameter named `lng`)\n2. a positive integer width (parameter named `wdth`)\n\nYou will return an array or a string (depending on the language; Shell bash, PowerShell and Fortran return a string) with the size of each of the  squares.\n\n```\n  sqInRect(5, 3) should return [3, 2, 1, 1]\n  sqInRect(3, 5) should return [3, 2, 1, 1]\n  or (Haskell)\n  squaresInRect  5  3 `shouldBe` Just [3,2,1,1]\n  squaresInRect  3  5 `shouldBe` Just [3,2,1,1]\n  or (Fsharp)\n  squaresInRect  5  3 should return Some [3,2,1,1]\n  squaresInRect  3  5 should return Some [3,2,1,1]\n  or (Swift)\n  squaresInRect  5  3 should return [3,2,1,1] as optional\n  squaresInRect  3  5 should return [3,2,1,1] as optional\n  or (Cpp)\n  sqInRect(5, 3) should return {3, 2, 1, 1}\n  sqInRect(3, 5) should return {3, 2, 1, 1}\n  (C)\n  C returns a structure, see the \"Solution\" and \"Examples\" tabs.\n  Your result and the reference test solution are compared by strings.\n```\n\n# Notes:\n- - lng == wdth as a starting case would be an entirely different problem and the drawing is planned to be interpreted with `lng != wdth`. (See kata, Square into Squares. Protect trees! http://www.codewars.com/kata/54eb33e5bc1a25440d000891 for this problem).\n \n - When the initial parameters are so that `lng` == `wdth`, the solution `[lng]` would be the most obvious but not in the spirit of this kata so, in that case, return `None`/`nil`/`null`/`Nothing`\n - return {} with C++, Array() with Scala.\n - In that case the returned structure of **C** will have its `sz` component equal to `0`. \n - Return the string `\"nil\"` with Bash, PowerShell and Fortran.\n\n\n- You can see more examples in **\"RUN SAMPLE TESTS\".**\n\n\n",
      "rank": -6,
      "rankName": "6 kyu",
      "tags": [
        "Puzzles",
        "Fundamentals",
        "Geometry",
        "Algebra",
        "Mathematics",
        "Algorithms",
        "Logic"
      ],
      "languages": [
        "python",
        "ruby",
        "java",
        "csharp",
        "clojure",
        "javascript",
        "haskell",
        "coffeescript",
        "cpp",
        "elixir",
        "typescript",
        "php",
        "crystal",
        "fsharp",
        "c",
        "rust",
        "swift",
        "r",
        "shell",
        "ocaml",
        "fortran",
        "julia",
        "scala",
        "powershell",
        "go",
        "nim",
        "kotlin",
        "racket",
        "reason"
      ]
    },
    {
      "id": "5547cc7dcad755e480000004",
      "name": "Is  my friend cheating?",
      "description": "- A friend of mine takes a sequence of numbers from 1 to n (where n > 0).\n- Within that sequence, he chooses two numbers, a and b.\n- He says that the product of a and b should be equal to the sum of all numbers in the sequence, excluding a and b.\n- Given a number n, could you tell me the numbers he excluded from the sequence?\n\nThe function takes the parameter: `n` \n(n is always strictly greater than 0) and returns an array or a string (depending on the language) of the form: \n```\n[(a, b), ...] or [[a, b], ...] or {{a, b}, ...} or or [{a, b}, ...]\n```\nwith **all** `(a, b)` which are the possible removed numbers in the sequence `1 to n`.\n\n`[(a, b), ...] or [[a, b], ...] or {{a, b}, ...} or ... `will be sorted in increasing order of the \"a\".\n\nIt happens that there are several possible (a, b).\nThe function returns an empty array (or an empty string) if no possible numbers are found which will prove that my friend has not told the truth! (Go: in this case return `nil`).\n\n(See examples of returns for each language in \"RUN SAMPLE TESTS\")\n\n# Examples:\n\n```\nremovNb(26) should return [(15, 21), (21, 15)]\n```\nor\n```\nremovNb(26) should return { {15, 21}, {21, 15} }\n```\nor\n```\nremoveNb(26) should return [[15, 21], [21, 15]]\n```\nor\n```\nremovNb(26) should return [ {15, 21}, {21, 15} ]\n```\nor\n```\nremovNb(26) should return \"15 21, 21 15\"\n```\nor\n```\nin C:\nremovNb(26) should return  **an array of pairs {{15, 21}{21, 15}}**\ntested by way of strings.\n```\n\n\n\n",
      "rank": -5,
      "rankName": "5 kyu",
      "tags": [
        "Puzzles",
        "Fundamentals",
        "Numbers",
        "Data Types",
        "Mathematics",
        "Algorithms",
        "Logic"
      ],
      "languages": [
        "python",
        "ruby",
        "csharp",
        "java",
        "clojure",
        "javascript",
        "haskell",
        "coffeescript",
        "typescript",
        "cpp",
        "elixir",
        "php",
        "crystal",
        "fsharp",
        "c",
        "rust",
        "swift",
        "go",
        "r",
        "shell",
        "ocaml",
        "fortran",
        "julia",
        "scala",
        "powershell",
        "nim",
        "racket",
        "reason",
        "kotlin",
        "prolog"
      ]
    },
    {
      "id": "554a44516729e4d80b000012",
      "name": "Buying a car",
      "description": "Let us begin with an example:\r\n\r\nA man has a rather old car being worth $2000. \r\nHe saw a secondhand car being worth $8000. He wants to keep his old car until he can buy the secondhand one.\r\n\r\nHe thinks he can save $1000 each month but the prices of his old \r\ncar and of the new one decrease of 1.5 percent per month.\r\nFurthermore this percent of loss increases of `0.5` percent \r\nat the end of every two months.\r\nOur man finds it difficult to make all these calculations.\r\n\r\n**Can you help him?**\r\n\r\nHow many months will it take him to save up enough money to buy the car he wants, and how much money will he have left over?\r\n\r\n**Parameters and return of function:**\r\n```\r\nparameter (positive int or float, guaranteed) startPriceOld (Old car price)\r\nparameter (positive int or float, guaranteed) startPriceNew (New car price)\r\nparameter (positive int or float, guaranteed) savingperMonth \r\nparameter (positive float or int, guaranteed) percentLossByMonth\r\n\r\nnbMonths(2000, 8000, 1000, 1.5) should return [6, 766] or (6, 766)\r\n```\r\n###  Detail of the above example:\r\n```\r\nend month 1: percentLoss 1.5 available -4910.0\r\nend month 2: percentLoss 2.0 available -3791.7999...\r\nend month 3: percentLoss 2.0 available -2675.964\r\nend month 4: percentLoss 2.5 available -1534.06489...\r\nend month 5: percentLoss 2.5 available -395.71327...\r\nend month 6: percentLoss 3.0 available 766.158120825...\r\nreturn [6, 766] or (6, 766)\r\n\r\n```\r\n\r\nwhere `6` is the number of months at **the end of which** he can buy the new car and `766` is the nearest integer to `766.158...` (rounding `766.158` gives `766`).\r\n\r\n**Note:** \r\n\r\nSelling, buying and saving are normally done at end of month.\r\nCalculations are processed at the end of each considered month\r\nbut if, by chance from the start, the value of the old car is bigger than the value of the new one or equal there is no saving to be made, no need to wait so he can at the beginning of the month buy the new car:\r\n```\r\nnbMonths(12000, 8000, 1000, 1.5) should return [0, 4000]\r\nnbMonths(8000, 8000, 1000, 1.5) should return [0, 0]\r\n```\r\n\r\nWe don't take care of a deposit of savings in a bank:-)\r\n\r\n\r\n",
      "rank": -6,
      "rankName": "6 kyu",
      "tags": [
        "Fundamentals",
        "Mathematics",
        "Algorithms",
        "Logic",
        "Numbers"
      ],
      "languages": [
        "ruby",
        "python",
        "csharp",
        "java",
        "clojure",
        "javascript",
        "haskell",
        "coffeescript",
        "typescript",
        "cpp",
        "elixir",
        "php",
        "crystal",
        "fsharp",
        "c",
        "rust",
        "swift",
        "go",
        "r",
        "shell",
        "ocaml",
        "fortran",
        "julia",
        "scala",
        "powershell",
        "nim",
        "reason",
        "racket",
        "kotlin",
        "prolog"
      ]
    },
    {
      "id": "554f76dca89983cc400000bb",
      "name": "Diophantine Equation",
      "description": "In mathematics, a [Diophantine equation](https://en.wikipedia.org/wiki/Diophantine_equation) is a polynomial equation, usually with two or more unknowns, such that only the integer solutions are sought or studied.\n\nIn this kata we want to find all integers `x, y` (`x >= 0, y >= 0`) solutions of a diophantine equation of the form:\n#### x<sup>2</sup> - 4 \\* y<sup>2</sup> = n\n\n(where the unknowns are `x` and `y`, and `n` is a given positive number)\nin decreasing order of the positive x<sub>i</sub>. \n\nIf there is no solution return `[]` or `\"[]\" or \"\"`. (See \"RUN SAMPLE TESTS\" for examples of returns).\n\n\n## Examples:\n\n```\nsolEquaStr(90005) --> \"[[45003, 22501], [9003, 4499], [981, 467], [309, 37]]\"\nsolEquaStr(90002) --> \"[]\"\n```\n\n## Hint:\n\nx<sup>2</sup> - 4 \\* y<sup>2</sup> = (x - 2\\*y) \\* (x + 2\\*y)",
      "rank": -5,
      "rankName": "5 kyu",
      "tags": [
        "Fundamentals",
        "Mathematics",
        "Algorithms",
        "Logic",
        "Numbers"
      ],
      "languages": [
        "ruby",
        "python",
        "clojure",
        "java",
        "csharp",
        "haskell",
        "javascript",
        "coffeescript",
        "typescript",
        "cpp",
        "elixir",
        "php",
        "crystal",
        "fsharp",
        "c",
        "rust",
        "swift",
        "go",
        "shell",
        "ocaml",
        "kotlin",
        "fortran",
        "julia",
        "scala",
        "r",
        "powershell",
        "nim",
        "racket",
        "reason",
        "prolog"
      ]
    },
    {
      "id": "5552101f47fc5178b1000050",
      "name": "Playing with digits",
      "description": "Some numbers have funny properties. For example:\n\n> 89 --> 8¹ + 9² = 89 * 1\n\n> 695 --> 6² + 9³ + 5⁴= 1390 = 695 * 2\n\n> 46288 --> 4³ + 6⁴+ 2⁵ + 8⁶ + 8⁷ = 2360688 = 46288 * 51\n\nGiven a positive integer n written as abcd... (a, b, c, d... being digits) and a positive integer p \n- we want to find a positive integer k, if it exists, such as the sum of the digits of n taken to the successive powers of p is equal to k * n. \n\nIn other words:\n\n\n> Is there an integer k such as : (a ^ p + b ^ (p+1) + c ^(p+2) + d ^ (p+3) + ...) = n * k\n\nIf it is the case we will return k, if not return -1.\n\n**Note**: n and p will always be given as strictly positive integers.\n\n```julia\ndig_pow(89, 1) should return 1 since 8¹ + 9² = 89 = 89 * 1\ndig_pow(92, 1) should return -1 since there is no k such as 9¹ + 2² equals 92 * k\ndig_pow(695, 2) should return 2 since 6² + 9³ + 5⁴= 1390 = 695 * 2\ndig_pow(46288, 3) should return 51 since 4³ + 6⁴+ 2⁵ + 8⁶ + 8⁷ = 2360688 = 46288 * 51\n```\n```rust\ndig_pow(89, 1) should return 1 since 8¹ + 9² = 89 = 89 * 1\ndig_pow(92, 1) should return -1 since there is no k such as 9¹ + 2² equals 92 * k\ndig_pow(695, 2) should return 2 since 6² + 9³ + 5⁴= 1390 = 695 * 2\ndig_pow(46288, 3) should return 51 since 4³ + 6⁴+ 2⁵ + 8⁶ + 8⁷ = 2360688 = 46288 * 51\n```\n```ruby\ndig_pow(89, 1) should return 1 since 8¹ + 9² = 89 = 89 * 1\ndig_pow(92, 1) should return -1 since there is no k such as 9¹ + 2² equals 92 * k\ndig_pow(695, 2) should return 2 since 6² + 9³ + 5⁴= 1390 = 695 * 2\ndig_pow(46288, 3) should return 51 since 4³ + 6⁴+ 2⁵ + 8⁶ + 8⁷ = 2360688 = 46288 * 51\n```\n```crystal\ndig_pow(89, 1) should return 1 since 8¹ + 9² = 89 = 89 * 1\ndig_pow(92, 1) should return -1 since there is no k such as 9¹ + 2² equals 92 * k\ndig_pow(695, 2) should return 2 since 6² + 9³ + 5⁴= 1390 = 695 * 2\ndig_pow(46288, 3) should return 51 since 4³ + 6⁴+ 2⁵ + 8⁶ + 8⁷ = 2360688 = 46288 * 51\n```\n```python\ndig_pow(89, 1) should return 1 since 8¹ + 9² = 89 = 89 * 1\ndig_pow(92, 1) should return -1 since there is no k such as 9¹ + 2² equals 92 * k\ndig_pow(695, 2) should return 2 since 6² + 9³ + 5⁴= 1390 = 695 * 2\ndig_pow(46288, 3) should return 51 since 4³ + 6⁴+ 2⁵ + 8⁶ + 8⁷ = 2360688 = 46288 * 51\n```\n```csharp\ndigPow(89, 1) should return 1 since 8¹ + 9² = 89 = 89 * 1\ndigPow(92, 1) should return -1 since there is no k such as 9¹ + 2² equals 92 * k\ndigPow(695, 2) should return 2 since 6² + 9³ + 5⁴= 1390 = 695 * 2\ndigPow(46288, 3) should return 51 since 4³ + 6⁴+ 2⁵ + 8⁶ + 8⁷ = 2360688 = 46288 * 51\n```\n```fsharp\ndigPow(89, 1) should return 1 since 8¹ + 9² = 89 = 89 * 1\ndigPow(92, 1) should return -1 since there is no k such as 9¹ + 2² equals 92 * k\ndigPow(695, 2) should return 2 since 6² + 9³ + 5⁴= 1390 = 695 * 2\ndigPow(46288, 3) should return 51 since 4³ + 6⁴+ 2⁵ + 8⁶ + 8⁷ = 2360688 = 46288 * 51\n```\n```ocaml\ndigPow(89, 1) should return 1 since 8¹ + 9² = 89 = 89 * 1\ndigPow(92, 1) should return -1 since there is no k such as 9¹ + 2² equals 92 * k\ndigPow(695, 2) should return 2 since 6² + 9³ + 5⁴= 1390 = 695 * 2\ndigPow(46288, 3) should return 51 since 4³ + 6⁴+ 2⁵ + 8⁶ + 8⁷ = 2360688 = 46288 * 51\n```\n```php\ndigPow(89, 1) should return 1 since 8¹ + 9² = 89 = 89 * 1\ndigPow(92, 1) should return -1 since there is no k such as 9¹ + 2² equals 92 * k\ndigPow(695, 2) should return 2 since 6² + 9³ + 5⁴= 1390 = 695 * 2\ndigPow(46288, 3) should return 51 since 4³ + 6⁴+ 2⁵ + 8⁶ + 8⁷ = 2360688 = 46288 * 51\n```\n```cpp\ndigPow(89, 1) should return 1 since 8¹ + 9² = 89 = 89 * 1\ndigPow(92, 1) should return -1 since there is no k such as 9¹ + 2² equals 92 * k\ndigPow(695, 2) should return 2 since 6² + 9³ + 5⁴= 1390 = 695 * 2\ndigPow(46288, 3) should return 51 since 4³ + 6⁴+ 2⁵ + 8⁶ + 8⁷ = 2360688 = 46288 * 51\n```\n```java\ndigPow(89, 1) should return 1 since 8¹ + 9² = 89 = 89 * 1\ndigPow(92, 1) should return -1 since there is no k such as 9¹ + 2² equals 92 * k\ndigPow(695, 2) should return 2 since 6² + 9³ + 5⁴= 1390 = 695 * 2\ndigPow(46288, 3) should return 51 since 4³ + 6⁴+ 2⁵ + 8⁶ + 8⁷ = 2360688 = 46288 * 51\n```\n```javascript\ndigPow(89, 1) should return 1 since 8¹ + 9² = 89 = 89 * 1\ndigPow(92, 1) should return -1 since there is no k such as 9¹ + 2² equals 92 * k\ndigPow(695, 2) should return 2 since 6² + 9³ + 5⁴= 1390 = 695 * 2\ndigPow(46288, 3) should return 51 since 4³ + 6⁴+ 2⁵ + 8⁶ + 8⁷ = 2360688 = 46288 * 51\n```\n```coffeescript\ndigPow(89, 1) should return 1 since 8¹ + 9² = 89 = 89 * 1\ndigPow(92, 1) should return -1 since there is no k such as 9¹ + 2² equals 92 * k\ndigPow(695, 2) should return 2 since 6² + 9³ + 5⁴= 1390 = 695 * 2\ndigPow(46288, 3) should return 51 since 4³ + 6⁴+ 2⁵ + 8⁶ + 8⁷ = 2360688 = 46288 * 51\n```\n```go\ndigPow(89, 1) should return 1 since 8¹ + 9² = 89 = 89 * 1\ndigPow(92, 1) should return -1 since there is no k such as 9¹ + 2² equals 92 * k\ndigPow(695, 2) should return 2 since 6² + 9³ + 5⁴= 1390 = 695 * 2\ndigPow(46288, 3) should return 51 since 4³ + 6⁴+ 2⁵ + 8⁶ + 8⁷ = 2360688 = 46288 * 51\n```\n```haskell\ndigpow 89 1 should return 1 since 8¹ + 9² = 89 = 89 * 1\ndigpow 92 1 should return -1 since there is no k such as 9¹ + 2² equals 92 * k\ndigpow 695 2 should return 2 since 6² + 9³ + 5⁴= 1390 = 695 * 2\ndigpow 46288 3 should return 51 since 4³ + 6⁴+ 2⁵ + 8⁶ + 8⁷ = 2360688 = 46288 * 51\n```\n```clojure\ndig-pow 89 1 should return 1 since 8¹ + 9² = 89 = 89 * 1\ndig-pow 92 1 should return -1 since there is no k such as 9¹ + 2² equals 92 * k\ndig-pow 695 2 should return 2 since 6² + 9³ + 5⁴= 1390 = 695 * 2\ndig-pow 46288 3 should return 51 since 4³ + 6⁴+ 2⁵ + 8⁶ + 8⁷ = 2360688 = 46288 * 51\n```\n```kotlin\ndigPow(89, 1) should return 1 since 8¹ + 9² = 89 = 89 * 1\ndigPow(92, 1) should return -1 since there is no k such as 9¹ + 2² equals 92 * k\ndigPow(695, 2) should return 2 since 6² + 9³ + 5⁴= 1390 = 695 * 2\ndigPow(46288, 3) should return 51 since 4³ + 6⁴+ 2⁵ + 8⁶ + 8⁷ = 2360688 = 46288 * 51\n```\n```nasm\nmov edi, 89\nmov esi, 1\ncall dig_pow  ; EAX <- 1 since 8¹ + 9² = 89 = 89 * 1\n\nmov edi, 92\nmov esi, 1\ncall dig_pow  ; EAX <- -1 since there is no k such as 9¹ + 2² equals 92 * k\n\nmov edi, 695\nmov esi, 2\ncall dig_pow  ; EAX <- 2 since 6² + 9³ + 5⁴= 1390 = 695 * 2\n\nmov edi, 46288\nmov esi, 3\ncall dig_pow  ; EAX <- 51 since 4³ + 6⁴+ 2⁵ + 8⁶ + 8⁷ = 2360688 = 46288 * 51\n```\n```lua\ndig_pow(89, 1) -- should return 1 since 8¹ + 9² = 89 = 89 * 1\ndig_pow(92, 1) -- should return -1 since there is no k such as 9¹ + 2² equals 92 * k\ndig_pow(695, 2) -- should return 2 since 6² + 9³ + 5⁴= 1390 = 695 * 2\ndig_pow(46288, 3) -- should return 51 since 4³ + 6⁴+ 2⁵ + 8⁶ + 8⁷ = 2360688 = 46288 * 51\n```",
      "rank": -6,
      "rankName": "6 kyu",
      "tags": [
        "Fundamentals",
        "Mathematics",
        "Algorithms",
        "Logic",
        "Numbers"
      ],
      "languages": [
        "ruby",
        "python",
        "csharp",
        "java",
        "javascript",
        "haskell",
        "clojure",
        "coffeescript",
        "cpp",
        "php",
        "crystal",
        "fsharp",
        "swift",
        "c",
        "typescript",
        "go",
        "shell",
        "ocaml",
        "julia",
        "scala",
        "r",
        "powershell",
        "kotlin",
        "nasm",
        "nim",
        "rust",
        "racket",
        "reason",
        "lua"
      ]
    },
    {
      "id": "5592e3bd57b64d00f3000047",
      "name": "Build a pile of Cubes",
      "description": "Your task is to construct a building which will be a pile of n cubes.\nThe cube at the bottom will have a volume of n^3, the cube above \nwill have  volume of (n-1)^3 and so on until the top which will have a volume of 1^3.\n\nYou are given the total volume m of the building.\nBeing given m can you find the number n of cubes you will have to build?\n\nThe parameter of the function findNb `(find_nb, find-nb, findNb)` will be an integer m\nand you have to return the integer n such as\nn^3 + (n-1)^3 + ... + 1^3 = m\nif such a n exists or -1 if there is no such n.\n\n## Examples:\n```\nfindNb(1071225) --> 45\nfindNb(91716553919377) --> -1\n```\n\n```nasm\nmov rdi, 1071225\ncall find_nb            ; rax <-- 45\n    \nmov rdi, 91716553919377\ncall find_nb            ; rax <-- -1\n```",
      "rank": -6,
      "rankName": "6 kyu",
      "tags": [
        "Fundamentals",
        "Optimization"
      ],
      "languages": [
        "csharp",
        "java",
        "ruby",
        "python",
        "javascript",
        "coffeescript",
        "haskell",
        "clojure",
        "elixir",
        "typescript",
        "cpp",
        "php",
        "crystal",
        "fsharp",
        "c",
        "swift",
        "rust",
        "go",
        "r",
        "shell",
        "ocaml",
        "fortran",
        "julia",
        "nasm",
        "nim",
        "scala",
        "kotlin",
        "groovy"
      ]
    },
    {
      "id": "559536379512a64472000053",
      "name": "Playing with passphrases",
      "description": "Everyone knows passphrases. One can choose passphrases from poems, songs, movies names and so on but frequently\nthey can be guessed due to common cultural references.\nYou  can get your passphrases stronger by different means. One is the following:\n\nchoose a text in capital letters including or not digits and non alphabetic characters,\n \n1. shift each letter by a given number but the transformed letter must be a letter (circular shift), \n2. replace each digit by its complement to 9, \n3. keep such as non alphabetic and non digit characters, \n4. downcase each letter in odd position, upcase each letter in even position (the first character is in position 0), \n5. reverse the whole result.\n\n#Example:\n\nyour text: \"BORN IN 2015!\", shift 1\n\n1 + 2 + 3 -> \"CPSO JO 7984!\"\n\n4 \"CpSo jO 7984!\"\n\n5 \"!4897 Oj oSpC\"\n\nWith longer passphrases it's better to have a small and easy program.\nWould you write it?\n\nhttps://en.wikipedia.org/wiki/Passphrase",
      "rank": -6,
      "rankName": "6 kyu",
      "tags": [
        "Algorithms",
        "Chars",
        "Data Types",
        "Strings",
        "Encoding",
        "Logic"
      ],
      "languages": [
        "ruby",
        "python",
        "csharp",
        "java",
        "javascript",
        "haskell",
        "coffeescript",
        "clojure",
        "typescript",
        "cpp",
        "php",
        "crystal",
        "c",
        "swift",
        "fsharp",
        "shell",
        "ocaml",
        "julia",
        "scala",
        "r",
        "nasm",
        "powershell",
        "go",
        "nim",
        "rust",
        "racket",
        "kotlin"
      ]
    },
    {
      "id": "559a28007caad2ac4e000083",
      "name": "Perimeter of squares in a rectangle",
      "description": "The drawing shows 6 squares the sides of which have a length of 1, 1, 2, 3, 5, 8.\nIt's easy to see that the sum of the perimeters of these squares is :\n` 4 * (1 + 1 + 2 + 3 + 5 + 8) = 4 * 20 = 80  `                                        \n\nCould you give the sum of the perimeters of all the squares in a rectangle when there are n + 1 squares disposed in the same manner as in the drawing: \n\n\n![alternative text](http://i.imgur.com/EYcuB1wm.jpg)\n\n#Hint: \nSee Fibonacci sequence\n#Ref:\nhttp://oeis.org/A000045\n\nThe function perimeter has for parameter n where n + 1 is the number of squares (they are numbered from 0 to n) and returns the total perimeter of all the squares.\n\n```\nperimeter(5)  should return 80\nperimeter(7)  should return 216\n```\n",
      "rank": -5,
      "rankName": "5 kyu",
      "tags": [
        "Algorithms",
        "Mathematics",
        "Logic",
        "Numbers"
      ],
      "languages": [
        "ruby",
        "python",
        "haskell",
        "clojure",
        "java",
        "csharp",
        "coffeescript",
        "javascript",
        "cpp",
        "php",
        "crystal",
        "fsharp",
        "c",
        "typescript",
        "rust",
        "swift",
        "go",
        "r",
        "shell",
        "objc",
        "ocaml",
        "fortran",
        "elixir",
        "julia",
        "scala",
        "powershell",
        "nim",
        "racket",
        "reason",
        "forth",
        "kotlin",
        "prolog"
      ]
    },
    {
      "id": "559e3224324a2b6e66000046",
      "name": "Functions of Integers on Cartesian Plane",
      "description": "Consider integer coordinates x, y in the Cartesian plan and three functions f, g, h\ndefined by:\n```\nf: 1 <= x <= n, 1 <= y <= n --> f(x, y) = min(x, y)\ng: 1 <= x <= n, 1 <= y <= n --> g(x, y) = max(x, y)\nh: 1 <= x <= n, 1 <= y <= n --> h(x, y) = x + y\n``` \nwhere n is a given integer (n >= 1, guaranteed) and x, y are integers.\n\nIn the table below you can see the value of the function f with n = 6.\n\n  ---|*0* |*1*|*2*|*3*|*4*|*5*|*6*|\n  -- |--|--|--|--|--|--|--|\n  *6*|- |1 |2 |3 |4 |5 |6 |\n  *5*|- |1 |2 |3 |4 |5 |5 |\n  *4*|- |1 |2 |3 |4 |4 |4 |\n  *3*|- |1 |2 |3 |3 |3 |3 |\n  *2*|- |1 |2 |2 |2 |2 |2 |\n  *1*|- |1 |1 |1 |1 |1 |1 |\n  *0*|- |- |- |- |- |- |- |\n\nThe task is to calculate the sum of f(x, y), g(x, y) and h(x, y) for all integers x and y such that (1 <= x <= n, 1 <= y <= n).\n\nThe function sumin (sum of f) will take n as a parameter and return the sum of min(x, y) in the domain 1 <= x <= n, 1 <= y <= n.\nThe function sumax (sum of g) will take n as a parameter and return the sum of max(x, y) in the same domain.\nThe function sumsum (sum of h) will take n as a parameter and return the sum of x + y in the same domain.\n\n\n#Examples:\n```\nsumin(6) --> 91\nsumin(45) --> 31395\nsumin(999) --> 332833500\nsumin(5000) --> 41679167500\n\nsumax(6) --> 161\nsumax(45) --> 61755\nsumax(999) --> 665167500\nsumax(5000) --> 83345832500\n\nsumsum(6) --> 252\nsumsum(45) --> 93150\nsumsum(999) --> 998001000\nsumsum(5000) --> 125025000000\n```\n\n#Hint:\n1. Try to avoid nested loops\n2. Note that h = f + g\n\n",
      "rank": -7,
      "rankName": "7 kyu",
      "tags": [
        "Fundamentals"
      ],
      "languages": [
        "ruby",
        "python",
        "java",
        "haskell",
        "clojure",
        "javascript",
        "coffeescript",
        "csharp",
        "typescript",
        "cpp",
        "elixir",
        "php",
        "crystal",
        "fsharp",
        "c",
        "ocaml",
        "r",
        "powershell",
        "go",
        "julia",
        "nim",
        "racket",
        "forth",
        "dart",
        "scala",
        "elm"
      ]
    },
    {
      "id": "559b8e46fa060b2c6a0000bf",
      "name": "Easy Diagonal",
      "description": "In the drawing below we have a part of the Pascal's triangle, lines are numbered from **zero** (top).\nThe left diagonal in pale blue with only numbers equal to 1 is diagonal **zero**, then in dark green \n(1, 2, 3, 4, 5, 6, 7) is diagonal 1, then in pale green (1, 3, 6, 10, 15, 21) is\ndiagonal 2 and so on.\n\nWe want to calculate the sum of the binomial coefficients on a given diagonal.\nThe sum on diagonal 0 is 8 (we'll write it S(7, 0), 7 is the number of the line where we start, \n0 is the number of the diagonal). In the same way S(7, 1) is 28, S(7, 2) is 56.\n\nCan you write a program which calculate S(n, p) where n is the line where we start and p \nis the number of the diagonal?\n\nThe function will take n and p (with: `n >= p >= 0`) as parameters and will return the sum.\n\n## Examples:\n```\ndiagonal(20, 3) => 5985\ndiagonal(20, 4) => 20349\n```\n## Hint:\nWhen following a diagonal from top to bottom have a look at the numbers on the diagonal at its right.\n\n## Ref:\nhttp://mathworld.wolfram.com/BinomialCoefficient.html\n\n![alternative text](http://i.imgur.com/eUGaNvIm.jpg)",
      "rank": -6,
      "rankName": "6 kyu",
      "tags": [
        "Fundamentals"
      ],
      "languages": [
        "ruby",
        "python",
        "haskell",
        "clojure",
        "java",
        "csharp",
        "javascript",
        "coffeescript",
        "elixir",
        "typescript",
        "cpp",
        "php",
        "fsharp",
        "c",
        "crystal",
        "ocaml",
        "rust",
        "swift",
        "go",
        "r",
        "nim",
        "shell",
        "fortran",
        "julia",
        "scala",
        "powershell",
        "racket",
        "vb",
        "forth",
        "kotlin",
        "prolog"
      ]
    },
    {
      "id": "559ce00b70041bc7b600013d",
      "name": "Financing Plan on Planet XY140Z-n",
      "description": "I need to save some money to buy a gift. I think I can do something like that:\n\nFirst week (W0) I save nothing on Sunday, 1 on Monday, 2 on Tuesday... 6 on Saturday,\nsecond week (W1) 2 on Monday... 7 on Saturday and so on according to the table below where the days are numbered from 0 to 6.\n\nCan you tell me how much I will have for my gift on Saturday evening after I have saved 12? (Your function finance(6) should return 168 which is the sum of the savings in the table). \n\nImagine now that we live on planet XY140Z-n where the days of the week are numbered from 0 to n (integer n > 0) and where\nI save from week number 0 to week number n included (in the table below n = 6).\n\nHow much money would I have at the end of my financing plan on planet XY140Z-n?\n\n\n\n  -- |Su|Mo|Tu|We|Th|Fr|Sa|\n   --|--|--|--|--|--|--|--|\n  W6 |  |  |  |  |  |  |12|\n  W5 |  |  |  |  |  |10|11|\n  W4 |  |  |  |  |8 |9 |10|\n  W3 |  |  |  |6 |7 |8 |9 |\n  W2 |  |  |4 |5 |6 |7 |8 |\n  W1 |  |2 |3 |4 |5 |6 |7 |\n  W0 |0 |1 |2 |3 |4 |5 |6 |\n  \n#Example:\n```\nfinance(5) --> 105\nfinance(6) --> 168\nfinance(7) --> 252\nfinance(5000) --> 62537505000\n```\n#Hint: \ntry to avoid nested loops\n",
      "rank": -6,
      "rankName": "6 kyu",
      "tags": [
        "Algorithms",
        "Mathematics",
        "Logic",
        "Numbers"
      ],
      "languages": [
        "ruby",
        "python",
        "haskell",
        "java",
        "clojure",
        "javascript",
        "coffeescript",
        "csharp",
        "typescript",
        "cpp",
        "elixir",
        "php",
        "crystal",
        "fsharp",
        "c",
        "rust",
        "swift",
        "go",
        "nim",
        "r",
        "shell",
        "ocaml",
        "fortran",
        "julia",
        "scala",
        "powershell",
        "reason",
        "racket",
        "forth",
        "factor",
        "kotlin",
        "prolog"
      ]
    },
    {
      "id": "55a29405bc7d2efaff00007c",
      "name": "Going to zero or to infinity?",
      "description": "Consider the following numbers (where `n!` is `factorial(n)`):\n```\nu1 = (1 / 1!) * (1!)\nu2 = (1 / 2!) * (1! + 2!)\nu3 = (1 / 3!) * (1! + 2! + 3!)\n...\nun = (1 / n!) * (1! + 2! + 3! + ... + n!)\n```\n\nWhich will win: `1 / n!` or `(1! + 2! + 3! + ... + n!)`?\n\nAre these numbers going to `0` because of `1/n!` or to infinity due\nto the sum of factorials or to another number?\n\n## Task\nCalculate `(1 / n!) * (1! + 2! + 3! + ... + n!)` \nfor a given `n`, where `n` is an integer greater or equal to `1`.\n\nTo avoid discussions about rounding, return the result **truncated** to 6 decimal places, for example:\n```\n1.0000989217538616 will be truncated to 1.000098\n1.2125000000000001 will be truncated to 1.2125\n```\n\n## Remark\nKeep in mind that factorials grow rather rapidly, and you need to handle large inputs.\n\n## Hint\nYou could try to simplify the expression.",
      "rank": -5,
      "rankName": "5 kyu",
      "tags": [
        "Algorithms",
        "Mathematics",
        "Logic",
        "Numbers"
      ],
      "languages": [
        "ruby",
        "python",
        "javascript",
        "haskell",
        "csharp",
        "java",
        "coffeescript",
        "clojure",
        "typescript",
        "cpp",
        "php",
        "crystal",
        "fsharp",
        "c",
        "rust",
        "swift",
        "go",
        "r",
        "shell",
        "ocaml",
        "fortran",
        "elixir",
        "julia",
        "scala",
        "powershell",
        "nim",
        "reason",
        "racket",
        "forth",
        "kotlin",
        "prolog",
        "haxe"
      ]
    },
    {
      "id": "55ab4f980f2d576c070000f4",
      "name": "Playing on a chessboard",
      "description": "With a friend we used to play the following game on a chessboard\n(8, rows, 8 columns).\nOn the first row at the *bottom* we put numbers:\n\n`1/2, 2/3, 3/4, 4/5, 5/6, 6/7, 7/8, 8/9`\n\nOn row 2 (2nd row from the bottom) we have:\n\n`1/3, 2/4, 3/5, 4/6, 5/7, 6/8, 7/9, 8/10`\n\nOn row 3:\n\n`1/4, 2/5, 3/6, 4/7, 5/8, 6/9, 7/10, 8/11`\n\nuntil last row:\n\n`1/9, 2/10, 3/11, 4/12, 5/13, 6/14, 7/15, 8/16`\n\n\nWhen all numbers are on the chessboard each in turn we toss a coin. The one who get \"head\" wins and\nthe other gives him, in dollars, the **sum of the numbers on the chessboard**.\nWe play for fun, the dollars come from a monopoly game! \n\n### Task\nHow much can I (or my friend) win or loses for each game if the chessboard has n rows and n columns? Add all of the fractional values on an n by n sized board and give the answer as a simplified fraction.\n  \n- Ruby, Python, JS, Coffee, Clojure, PHP, Elixir, Crystal, Typescript, Go:\n\nThe function called 'game' with parameter n (integer >= 0) returns as result an irreducible fraction written as an array of integers: [numerator, denominator].\nIf the denominator is 1 return [numerator].\n\n- Haskell:\n\n'game' returns either a \"Left Integer\" if denominator is 1 otherwise \n\"Right (Integer, Integer)\" \n\n- Prolog:\n'game' returns an irreducible fraction written as an array of integers: [numerator, denominator].\nIf the denominator is 1 return [numerator, 1].\n\n- Java, C#, C++, F#, Swift, Reason, Kotlin:\n\n'game' returns a string that mimicks the array returned in Ruby, Python, JS, etc...\n\n- Fortran, Bash: 'game' returns a string\n\n\n- Forth: return on the stack the numerator and the denominator (even if the denominator is 1)\n\n\n- In Fortran - as in any other language - the returned string is not permitted\nto contain any redundant trailing whitespace: you can use dynamically allocated character strings.\n\n#### See Example Test Cases for each language\n",
      "rank": -6,
      "rankName": "6 kyu",
      "tags": [
        "Fundamentals",
        "Puzzles",
        "Games"
      ],
      "languages": [
        "ruby",
        "python",
        "javascript",
        "java",
        "csharp",
        "haskell",
        "clojure",
        "coffeescript",
        "cpp",
        "elixir",
        "typescript",
        "php",
        "crystal",
        "fsharp",
        "c",
        "rust",
        "swift",
        "go",
        "r",
        "nim",
        "shell",
        "ocaml",
        "fortran",
        "julia",
        "scala",
        "powershell",
        "reason",
        "racket",
        "forth",
        "kotlin",
        "prolog"
      ]
    },
    {
      "id": "55aa075506463dac6600010d",
      "name": "Integers: Recreation One",
      "description": "Divisors of 42 are : 1, 2, 3, 6, 7, 14, 21, 42.\nThese divisors squared are: 1, 4, 9, 36, 49, 196, 441, 1764.\nThe sum of the squared divisors is 2500 which is 50 * 50, a square!\n\nGiven two integers m, n (1 <= m <= n) we want to find all integers \nbetween m and n whose sum of squared divisors is itself a square.\n42 is such a number.\n\nThe result will be an array of arrays or of tuples (in C an array of Pair) or a string, each subarray having two elements,\nfirst the number whose squared divisors is a square and then the sum\nof the squared divisors.\n\n#Examples:\n```\nlist_squared(1, 250) --> [[1, 1], [42, 2500], [246, 84100]]\nlist_squared(42, 250) --> [[42, 2500], [246, 84100]]\n```\n\nThe form of the examples may change according to the language, see `Example Tests:` for more details.\n\n**Note**\n\nIn Fortran - as in any other language - the returned string is not permitted to contain any redundant trailing whitespace: you can use dynamically allocated character strings.\n\n",
      "rank": -5,
      "rankName": "5 kyu",
      "tags": [
        "Fundamentals",
        "Algorithms",
        "Logic",
        "Optimization"
      ],
      "languages": [
        "ruby",
        "python",
        "javascript",
        "java",
        "csharp",
        "coffeescript",
        "haskell",
        "clojure",
        "cpp",
        "php",
        "crystal",
        "fsharp",
        "c",
        "typescript",
        "rust",
        "swift",
        "go",
        "r",
        "shell",
        "ocaml",
        "elixir",
        "fortran",
        "julia",
        "scala",
        "powershell",
        "nim",
        "purescript",
        "reason",
        "racket",
        "kotlin",
        "prolog"
      ]
    },
    {
      "id": "55b3425df71c1201a800009c",
      "name": "Statistics for an Athletic Association",
      "description": "You are the \"computer expert\" of a local Athletic Association (C.A.A.).\nMany teams of runners come to compete. Each time you get a string of \nall race results of every team who has run.\nFor example here is a string showing the individual results of a team of 5 runners:\n\n` \"01|15|59, 1|47|6, 01|17|20, 1|32|34, 2|3|17\" `\n\nEach part of the string is of the form: ` h|m|s `\nwhere h, m, s (h for hour, m for minutes, s for seconds) are positive or null integer (represented as strings) with one or two digits.\nThere are no traps in this format.\n\nTo compare the results of the teams you are asked for giving\nthree statistics; **range, average and median**.\n\n`Range` : difference between the lowest and highest values. \nIn {4, 6, 9, 3, 7} the lowest value is 3, and the highest is 9, \nso the range is 9 − 3 = 6.\n\n`Mean or Average` : To calculate mean, add together all of the numbers \nin a set and then divide the sum by the total count of numbers.\n\n`Median` : In statistics, the median is the number separating the higher half \nof a data sample from the lower half. \nThe median of a finite list of numbers can be found by arranging all \nthe observations from lowest value to highest value and picking the middle one \n(e.g., the median of {3, 3, 5, 9, 11} is 5) when there is an odd number of observations. \nIf there is an even number of observations, then there is no single middle value; \nthe median is then defined to be the mean of the two middle values\n(the median of {3, 5, 6, 9} is (5 + 6) / 2 = 5.5).\n\nYour task is to return a string giving these 3 values.  For the example given above,\nthe string result will be\n\n`\"Range: 00|47|18 Average: 01|35|15 Median: 01|32|34\"`\n\nof the form:\n\n`\"Range: hh|mm|ss Average: hh|mm|ss Median: hh|mm|ss\"`\n\nwhere hh, mm, ss are integers (represented by strings) with *each 2 digits*.\n\n*Remarks*: \n\n1. if a result in seconds is ab.xy... it will be given **truncated** as ab.\n\n2. if the given string is \"\" you will return \"\"\n",
      "rank": -6,
      "rankName": "6 kyu",
      "tags": [
        "Fundamentals",
        "Strings",
        "Data Types"
      ],
      "languages": [
        "ruby",
        "python",
        "javascript",
        "haskell",
        "java",
        "csharp",
        "clojure",
        "coffeescript",
        "cpp",
        "php",
        "c",
        "swift",
        "crystal",
        "typescript",
        "r",
        "shell",
        "ocaml",
        "elixir",
        "fsharp",
        "julia",
        "scala",
        "powershell",
        "go",
        "nim",
        "rust",
        "reason",
        "racket",
        "kotlin"
      ]
    },
    {
      "id": "55b4d87a3766d9873a0000d4",
      "name": "How Much?",
      "description": "I always thought that my old friend John was rather richer than he looked, but I never knew exactly how much money he actually had. One day (as I was plying him with questions) he said:\n\n* \"Imagine I have between `m` and `n` Zloty...\" (or did he say Quetzal? I can't remember!)\n* \"If I were to buy **9** cars costing `c` each, I'd only have 1 Zloty (or was it Meticals?) left.\"\n* \"And if I were to buy **7** boats at `b` each, I'd only have 2 Ringglets (or was it Zloty?) left.\"\n\nCould you tell me in each possible case:\n\n1. how much money `f` he could possibly have ?\n2. the cost `c` of a car?\n3. the cost `b` of a boat?\n\nSo, I will have a better idea about his fortune. Note that if `m-n` is big enough, you might have a lot of possible answers. \n\nEach answer should be given as `[\"M: f\", \"B: b\", \"C: c\"]` and all the answers as `[ [\"M: f\", \"B: b\", \"C: c\"], ... ]`. \"M\" stands for money, \"B\" for boats, \"C\" for cars.\n\n**Note:** `m, n, f, b, c` are positive integers, where `0 <= m <= n` or `m >= n >= 0`. `m` and `n` are inclusive.\n\n\n## Examples:\n```\nhowmuch(1, 100)      => [[\"M: 37\", \"B: 5\", \"C: 4\"], [\"M: 100\", \"B: 14\", \"C: 11\"]]\nhowmuch(1000, 1100)  => [[\"M: 1045\", \"B: 149\", \"C: 116\"]]\nhowmuch(10000, 9950) => [[\"M: 9991\", \"B: 1427\", \"C: 1110\"]]\nhowmuch(0, 200)      => [[\"M: 37\", \"B: 5\", \"C: 4\"], [\"M: 100\", \"B: 14\", \"C: 11\"], [\"M: 163\", \"B: 23\", \"C: 18\"]]\n```\n\nExplanation of the results for `howmuch(1, 100)`:\n\n* In the first answer his possible fortune is **37**:\n * so he can buy 7 boats each worth 5: `37 - 7 * 5 = 2`\n * or he can buy 9 cars worth 4 each: `37 - 9 * 4 = 1`\n* The second possible answer is **100**:\n * he can buy 7 boats each worth 14: `100 - 7 * 14 = 2`\n * or he can buy 9 cars worth 11: `100 - 9 * 11 = 1`\n\n# Note\nSee \"Sample Tests\" to know the format of the return.\n",
      "rank": -6,
      "rankName": "6 kyu",
      "tags": [
        "Fundamentals"
      ],
      "languages": [
        "ruby",
        "python",
        "javascript",
        "haskell",
        "java",
        "csharp",
        "clojure",
        "coffeescript",
        "typescript",
        "cpp",
        "elixir",
        "php",
        "crystal",
        "fsharp",
        "c",
        "rust",
        "swift",
        "go",
        "r",
        "shell",
        "ocaml",
        "kotlin",
        "fortran",
        "julia",
        "scala",
        "powershell",
        "nim",
        "reason",
        "racket",
        "prolog"
      ]
    },
    {
      "id": "55be10de92aad5ef28000023",
      "name": "Color Choice",
      "description": "You know combinations: for example, \r\nif you take 5 cards from a 52 cards deck you have 2,598,960 different combinations.\r\n\r\nIn mathematics the number of x combinations you can take from a set of n elements\r\nis called the binomial coefficient of n and x, or more often `n choose x`.\r\nThe formula to compute `m = n choose x` is: `m = n! / (x! * (n - x)!)`\r\nwhere ! is the factorial operator.\r\n\r\nYou are a renowned poster designer and painter. You are asked to provide 6 posters \r\nall having the same design each in 2 colors. Posters must all have a different color combination and you have the choice of 4 colors: red, blue, yellow, green. \r\nHow many colors can you choose for each poster?\r\n\r\nThe answer is two since `4 choose 2 = 6`. The combinations will be:\r\n{red, blue}, {red, yellow}, {red, green}, {blue, yellow}, {blue, green}, {yellow, green}.\r\n\r\nNow same question but you have 35 posters to provide and 7 colors available. How many colors for each poster?\r\nIf you take combinations `7 choose 2` you will get 21 with the above formula.\r\nBut 21 schemes aren't enough for 35 posters. If you take `7 choose 5` combinations you will get 21 too.\r\nFortunately if you take `7 choose 3` or `7 choose 4` combinations you get 35 and so each poster will have a different combination of\r\n3 colors or 5 colors. You will take 3 colors because it's less expensive.\r\n\r\nHence the problem is: \r\n\r\nknowing `m` (number of posters to design), \r\nknowing `n` (total number of available colors), \r\nlet us \r\nsearch `x` (number of colors for each poster so that each poster has a unique combination of colors and the number of combinations is exactly the same as the number of posters).\r\n\r\nIn other words we must find **x** such as `n choose x = m (1)` for a given m and a given n;\r\n`m >= 0 and n > 0`. If many x are solutions give as result the smallest x.\r\nIt can happen that when m is given at random there are no x satisfying `equation (1)` then\r\nreturn -1.\r\n\r\nExamples:\r\n```\r\ncheckchoose(6, 4) --> 2\r\ncheckchoose(4, 4) --> 1\r\ncheckchoose(4, 2) --> -1\r\ncheckchoose(35, 7) --> 3\r\ncheckchoose(36, 7) --> -1\r\n\r\na = 47129212243960\r\ncheckchoose(a, 50) --> 20\r\ncheckchoose(a + 1, 50) --> -1\r\n```\r\n",
      "rank": -6,
      "rankName": "6 kyu",
      "tags": [
        "Fundamentals"
      ],
      "languages": [
        "ruby",
        "python",
        "javascript",
        "java",
        "csharp",
        "haskell",
        "clojure",
        "coffeescript",
        "elixir",
        "typescript",
        "cpp",
        "php",
        "crystal",
        "fsharp",
        "c",
        "rust",
        "swift",
        "go",
        "r",
        "shell",
        "ocaml",
        "kotlin",
        "fortran",
        "julia",
        "scala",
        "powershell",
        "nim",
        "racket",
        "prolog"
      ]
    },
    {
      "id": "55c6126177c9441a570000cc",
      "name": "Weight for weight",
      "description": "My friend John and I are members of the \"Fat to Fit Club (FFC)\". John is worried because\neach month a list with the weights of members is published and each month he is the last on the list\nwhich means he is the heaviest. \n\nI am the one who establishes the list so I told him:\n\"Don't worry any more, I will modify the order of the list\".\nIt was decided to attribute a \"weight\" to numbers. The weight of a number will be from now on\nthe sum of its digits. \n\nFor example `99` will have \"weight\" `18`, `100` will have \"weight\"\n`1` so in the list `100` will come before `99`.\nGiven a string with the weights of FFC members in normal order can you give this string ordered by \"weights\" of these numbers?\n\n# Example:\n\n`\"56 65 74 100 99 68 86 180 90\"` ordered by numbers weights becomes: \n`\"100 180 90 56 65 74 68 86 99\"`\n\nWhen two numbers have the same \"weight\", let us class them as if they were strings (alphabetical ordering) and not numbers:\n`100` is before `180` because its \"weight\" (1) is less than the one of `180` (9)\nand `180` is before `90` since, having the same \"weight\" (9),  it comes before as a *string*.\n\nAll numbers in the list are positive numbers and the list can be empty.\n\n# Notes\n\n- it may happen that the input string have leading, trailing whitespaces and more than a unique whitespace between two consecutive numbers\n- Don't modify the input\n- For C: The result is freed.\n",
      "rank": -5,
      "rankName": "5 kyu",
      "tags": [
        "Algorithms",
        "Numbers",
        "Data Types"
      ],
      "languages": [
        "ruby",
        "python",
        "javascript",
        "haskell",
        "java",
        "csharp",
        "clojure",
        "coffeescript",
        "cpp",
        "php",
        "crystal",
        "c",
        "typescript",
        "rust",
        "swift",
        "fsharp",
        "r",
        "shell",
        "ocaml",
        "kotlin",
        "objc",
        "lua",
        "scala",
        "elixir",
        "julia",
        "powershell",
        "go",
        "nim",
        "reason",
        "racket"
      ]
    },
    {
      "id": "55cf3b567fc0e02b0b00000b",
      "name": "Getting along with Integer Partitions",
      "description": "From wikipedia <https://en.wikipedia.org/wiki/Partition_(number_theory)> \n\nIn number theory and combinatorics, a partition of a positive integer n, also called an integer partition, \nis a way of writing n as a sum of positive integers. \nTwo sums that differ only in the order of their summands are considered the **same** partition.\n\nFor example, 4 can be partitioned in five distinct ways:\n\n`4, 3 + 1, 2 + 2, 2 + 1 + 1, 1 + 1 + 1 + 1`.\n\nWe can write:\n\n`enum(4) -> [[4],[3,1],[2,2],[2,1,1],[1,1,1,1]]` and\n\n`enum(5) -> [[5],[4,1],[3,2],[3,1,1],[2,2,1],[2,1,1,1],[1,1,1,1,1]]`.\n\nThe number of parts in a partition grows very fast.\nFor n = 50 number of parts is `204226`, for 80 it is `15,796,476`\nIt would be too long to tests answers with arrays of such size. So our task is the following:\n\n1 - n being given (n integer, 1 <= n <= 50) calculate enum(n) ie the partition of n.\nWe will obtain something like that:  \n`enum(n) -> [[n],[n-1,1],[n-2,2],...,[1,1,...,1]]` (order of array and sub-arrays\ndoesn't matter). This part is not tested.\n\n2 - For each sub-array of enum(n) calculate its product. \nIf n = 5 we'll obtain **after removing duplicates and sorting**:\n\n`prod(5) -> [1,2,3,4,5,6]`\n\n`prod(8) -> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 15, 16, 18]`\n\nIf n = 40 prod(n) has a length of `2699` hence the tests will not verify such arrays.\nInstead our task number 3 is:\n\n3 - return the range, the average and the median of prod(n) in the following form \n(example for n = 5):\n\n`\"Range: 5 Average: 3.50 Median: 3.50\"`\n\nRange is an integer, Average and Median are float numbers rounded to two decimal \nplaces (\".2f\" in some languages).\n\n#Notes:\n`Range` : difference between the highest and lowest values. \n\n`Mean or Average` : To calculate mean, add together all of the numbers \nin a set and then divide the sum by the total count of numbers.\n\n`Median` : The median is the number separating the higher half \nof a data sample from the lower half. \n(https://en.wikipedia.org/wiki/Median)\n\n#Hints:\nTry to optimize your program to avoid timing out.\n\nMemoization can be helpful but it is not mandatory for being successful.\n",
      "rank": -4,
      "rankName": "4 kyu",
      "tags": [
        "Fundamentals",
        "Algorithms",
        "Logic",
        "Optimization"
      ],
      "languages": [
        "ruby",
        "python",
        "javascript",
        "haskell",
        "java",
        "csharp",
        "coffeescript",
        "clojure",
        "cpp",
        "php",
        "rust",
        "c",
        "crystal",
        "swift",
        "typescript",
        "go",
        "r",
        "shell",
        "ocaml",
        "fsharp",
        "scala",
        "julia",
        "nim",
        "racket",
        "reason",
        "fortran"
      ]
    },
    {
      "id": "55e2adece53b4cdcb900006c",
      "name": "Tortoise racing",
      "description": "Two tortoises named ***A*** and ***B*** must run a race. ***A*** starts with an average speed of ```720 feet per hour```.\nYoung ***B*** knows she runs faster than ***A***, and furthermore has not finished her cabbage.\n\nWhen she starts, at last, she can see that ***A*** has a `70 feet lead` but ***B***'s speed is `850 feet per hour`.\nHow long will it take ***B*** to catch ***A***?\n\nMore generally:\ngiven two speeds `v1` (***A***'s speed, integer > 0) and `v2` (***B***'s speed, integer > 0) and a lead `g` (integer > 0)\nhow long will it take ***B*** to catch ***A***? \n\nThe result will be an array ```[hour, min, sec]``` which is the time needed in hours, minutes and seconds (round down to the nearest second)\nor a string in some languages.\n\nIf `v1 >= v2` then return `nil`, `nothing`, `null`, `None` or `{-1, -1, -1}` for C++, C, Go, Nim, `[]` for Kotlin or \"-1 -1 -1\".\n\n## Examples:\n(form of the result depends on the language)\n```\nrace(720, 850, 70) => [0, 32, 18] or \"0 32 18\"\nrace(80, 91, 37)   => [3, 21, 49] or \"3 21 49\"\n```\n\n** Note: \n\n- See other examples in \"Your test cases\".\n\n- In Fortran - as in any other language - the returned string is not permitted to contain any redundant trailing whitespace: you can use dynamically allocated character strings.\n\n** Hints for people who don't know how to convert to hours, minutes, seconds:\n\n- Tortoises don't care about fractions of seconds\n\n- Think of calculation by hand using only integers (in your code use or simulate integer division)\n\n- or Google: \"convert decimal time to hours minutes seconds\"\n\n\n\n",
      "rank": -6,
      "rankName": "6 kyu",
      "tags": [
        "Fundamentals"
      ],
      "languages": [
        "ruby",
        "python",
        "javascript",
        "haskell",
        "java",
        "csharp",
        "clojure",
        "coffeescript",
        "cpp",
        "php",
        "crystal",
        "fsharp",
        "c",
        "typescript",
        "rust",
        "swift",
        "go",
        "r",
        "nim",
        "shell",
        "ocaml",
        "kotlin",
        "groovy",
        "fortran",
        "elixir",
        "julia",
        "scala",
        "powershell",
        "reason",
        "racket"
      ]
    },
    {
      "id": "55e86e212fce2aae75000060",
      "name": "Integers: Recreation Two",
      "description": "We are still with squared integers.\n\nGiven 4 integers `a, b, c, d` we form the sum of the squares of `a` and `b`\nand then the sum of the squares of `c` and `d`. We multiply the two sums hence a number `n` and we try to\ndecompose `n` in a sum of two squares `e` and `f` (e and f integers >= 0) so that `n = e² + f²`. \n\nMore: `e` and `f` must result only from sums (or differences) of products between on the one hand `(a, b)` and on the other `(c, d)` each of `a, b, c, d` taken only once. \nFor example, \nprod2sum(1, 2, 1, 3) should return [[1, 7], [5, 5]]) \nbecause \n```\n1==1*3-1*2\n7==2*3+1*1\n5==1*2+1*3\n```\nSuppose we have `a = 1, b = 2, c = 1, d = 3`. First we calculate the sums \n`1² + 2² = 5 and 1² + 3² = 10` hence `n = 50`.\n\n\n\n`50 = 1² + 7² or 50 = 7² + 1²` (we'll consider that these two solutions are the same)\nor `50 = 5² + 5²`. \n\nThe return of our function will be an array of subarrays (in C an array of Pairs) sorted on the first elements of the subarrays. In each subarray the lower element should be the first.\n\n`prod2sum(1, 2, 1, 3) should return [[1, 7], [5, 5]]`\n\n`prod2sum(2, 3, 4, 5) should return  [[2, 23], [7, 22]]`\n\nbecause `(2² + 3²) * (4² + 5²) = 533 = (7² + 22²) = (23² + 2²)`\n\n`prod2sum(1, 2, 2, 3) should return  [[1, 8], [4, 7]]`\n\n`prod2sum(1, 1, 3, 5) should return  [[2, 8]]` (there are not always 2 solutions).\n\n##Hint\nTake a sheet of paper and with a bit of algebra try to write the product of squared numbers in another way.",
      "rank": -6,
      "rankName": "6 kyu",
      "tags": [
        "Fundamentals",
        "Mathematics",
        "Algorithms",
        "Logic",
        "Numbers",
        "Puzzles",
        "Games"
      ],
      "languages": [
        "ruby",
        "python",
        "javascript",
        "java",
        "csharp",
        "haskell",
        "clojure",
        "coffeescript",
        "cpp",
        "php",
        "crystal",
        "c",
        "typescript",
        "rust",
        "swift",
        "go",
        "fsharp",
        "r",
        "shell",
        "ocaml",
        "kotlin",
        "elixir",
        "julia",
        "powershell",
        "nim",
        "reason",
        "racket",
        "scala"
      ]
    },
    {
      "id": "55e6f5e58f7817808e00002e",
      "name": "A Rule of Divisibility by 7",
      "description": "A number m of the form 10x + y is divisible by 7 if and only if x − 2y is divisible by 7. In other words, subtract twice the last digit \nfrom the number formed by the remaining digits. Continue to do this until a number known to be divisible or not by 7 is obtained; \nyou can stop when this number has *at most* 2 digits because you are supposed to know if a number of at most 2 digits is divisible by 7 or not.\n\nThe original number is divisible by 7 if and only if the last number obtained using this procedure is divisible by 7. \n\nExamples:\n\n1 - `m = 371 -> 37 − (2×1) -> 37 − 2 = 35` ; thus, since 35 is divisible by 7, 371 is divisible by 7. \n\nThe number of steps to get the result is `1`.\n\n2 - `m = 1603 -> 160 - (2 x 3) -> 154 -> 15 - 8 = 7` and 7 is divisible by 7. \n\n3 - `m = 372 -> 37 − (2×2) -> 37 − 4 = 33` ; thus, since 33 is not divisible by 7, 372 is not divisible by 7. \n\nThe number of steps to get the result is `1`.\n\n4 - `m = 477557101->47755708->4775554->477547->47740->4774->469->28` and 28 is divisible by 7, so is 477557101. \n\nThe number of steps is 7.\n\n# Task:\nYour task is to return to the function ```seven(m)``` (m integer >= 0) an array (or a pair, depending on the language) of numbers, \nthe first being the *last* number `m` with at most 2 digits obtained by your function (this last `m` will be divisible or not by 7), the second one being the number of steps to get the result.\n\n## Forth Note:\nReturn on the stack `number-of-steps, last-number-m-with-at-most-2-digits `\n\n## Examples:\n```\nseven(371) should return [35, 1]\nseven(1603) should return [7, 2]\nseven(477557101) should return [28, 7]\n```",
      "rank": -7,
      "rankName": "7 kyu",
      "tags": [
        "Fundamentals"
      ],
      "languages": [
        "ruby",
        "python",
        "javascript",
        "haskell",
        "java",
        "csharp",
        "clojure",
        "coffeescript",
        "typescript",
        "elixir",
        "cpp",
        "php",
        "crystal",
        "fsharp",
        "c",
        "shell",
        "ocaml",
        "kotlin",
        "nasm",
        "julia",
        "r",
        "powershell",
        "go",
        "nim",
        "rust",
        "reason",
        "racket",
        "forth",
        "factor",
        "scala",
        "prolog",
        "fortran",
        "haxe"
      ]
    },
    {
      "id": "55e7280b40e1c4a06d0000aa",
      "name": "Best travel",
      "description": "John and Mary want to travel between a few towns A, B, C ... Mary has on a sheet of paper a list of distances between these towns.\n`ls = [50, 55, 57, 58, 60]`.\nJohn is tired of driving and he says to Mary that he doesn't want to drive more than `t = 174 miles` and he\nwill visit only `3` towns.\n\nWhich distances, hence which towns, they will choose so that the sum of the distances is the biggest possible to please Mary and John?\n\nExample: \n\nWith list `ls` and 3 towns to visit they can make a choice between: \n`[50,55,57],[50,55,58],[50,55,60],[50,57,58],[50,57,60],[50,58,60],[55,57,58],[55,57,60],[55,58,60],[57,58,60]`.\n\nThe sums of distances are then:\n`162, 163, 165, 165, 167, 168, 170, 172, 173, 175`.\n\nThe biggest possible sum taking a limit of `174` into account is then `173` and the distances of the `3` \ncorresponding towns is `[55, 58, 60]`.\n\nThe function `chooseBestSum` (or `choose_best_sum` or ... depending on the language) will take as parameters `t` (maximum sum of distances, integer >= 0), `k` (number of towns to visit, k >= 1) \nand `ls` (list of distances, all distances are positive or null integers and this list has at least one element).\nThe function returns the \"best\" sum ie the biggest possible sum of `k` distances less than or equal to the given limit `t`, if that sum exists,\nor otherwise nil, null, None, Nothing, depending on the language. With C++, C, Rust, Swift, Go, Kotlin return `-1`.\n\nExamples: \n\n`ts = [50, 55, 56, 57, 58]`\n`choose_best_sum(163, 3, ts) -> 163`\n\n`xs = [50]`\n`choose_best_sum(163, 3, xs) -> nil (or null or ... or -1 (C++, C, Rust, Swift, Go)`\n\n`ys = [91, 74, 73, 85, 73, 81, 87]`\n`choose_best_sum(230, 3, ys) -> 228`\n\nNote: don't modify the input list `ls`\n",
      "rank": -5,
      "rankName": "5 kyu",
      "tags": [
        "Fundamentals"
      ],
      "languages": [
        "ruby",
        "python",
        "haskell",
        "java",
        "csharp",
        "clojure",
        "javascript",
        "coffeescript",
        "cpp",
        "php",
        "c",
        "rust",
        "swift",
        "crystal",
        "typescript",
        "go",
        "fsharp",
        "r",
        "shell",
        "ocaml",
        "kotlin",
        "elixir",
        "scala",
        "julia",
        "powershell",
        "nim",
        "reason",
        "racket",
        "fortran"
      ]
    },
    {
      "id": "55efecb8680f47654c000095",
      "name": "Hero's root",
      "description": "One of the first algorithm used for approximating the integer square root of a positive integer `n` is known as \"Hero's method\", \nnamed after the first-century Greek mathematician Hero of Alexandria who gave the first description\nof the method. Hero's method can be obtained from Newton's method which came 16 centuries after. \n\nWe approximate the square root of a number `n` by taking an initial guess `x`, an error `e` and repeatedly calculating a new approximate *integer* value `x` using: `(x + n / x) / 2`; we are finished when the previous `x` and the `new x` have an absolute difference less than `e`.\n\nWe supply to a function (int_rac) a number `n` (positive integer) and a parameter `guess` (positive integer) which will be our initial `x`. For this kata the parameter 'e' is set to `1`.\n\nHero's algorithm is not always going to come to an exactly correct result! For instance: if n = 25 we get 5 but for n = 26 we also get 5. Nevertheless `5` is the *integer* square root of `26`.\n\nThe kata is to return the count of the progression of integer approximations that the algorithm makes.\n\nReference:\n\n<https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method>\n\nSome examples:\n```\nint_rac(25,1): follows a progression of [1,13,7,5] so our function should return 4.\n\nint_rac(125348,300): has a progression of [300,358,354] so our function should return 3.\n\nint_rac(125348981764,356243): has a progression of [356243,354053,354046] so our function should return 3.\n```\n\n#\n\nYou can use Math.floor (or similar) for each integer approximation.\n \n#\n\nNote for JavaScript, Coffescript, Typescript:\n\nDon't use the double bitwise NOT ~~ at each iteration if you want to have the same results as in the tests and the other languages. \n",
      "rank": -7,
      "rankName": "7 kyu",
      "tags": [
        "Fundamentals"
      ],
      "languages": [
        "ruby",
        "python",
        "javascript",
        "haskell",
        "java",
        "csharp",
        "clojure",
        "coffeescript",
        "typescript",
        "cpp",
        "elixir",
        "php",
        "crystal",
        "fsharp",
        "c",
        "shell",
        "ocaml",
        "kotlin",
        "fortran",
        "julia",
        "r",
        "powershell"
      ]
    },
    {
      "id": "55f3da49e83ca1ddae0000ad",
      "name": "Tank Truck",
      "description": "To introduce the problem think to my neighbor who drives a tanker truck. \nThe level indicator is down and he is worried\nbecause he does not know if he will be able to make deliveries. \nWe put the truck on a horizontal ground and measured the height of the liquid in the tank.\n\nFortunately the tank is a perfect cylinder and the vertical walls on each end are flat.\nThe height of the remaining liquid is `h`, the diameter of the cylinder is `d`,\nthe total volume is `vt` (h, d, vt are positive or null integers). \nYou can assume that `h` <= `d`.\n\nCould you calculate the remaining volume of the liquid?\nYour function `tankvol(h, d, vt)` returns an integer which is the truncated result (e.g floor)\nof your float calculation.\n\nExamples:\n\n```\ntankvol(40,120,3500) should return 1021 (calculation gives about: 1021.26992027)\n\ntankvol(60,120,3500) should return 1750\n\ntankvol(80,120,3500) should return 2478 (calculation gives about: 2478.73007973)\n```\n\nTank vertical section:\n\n![alternative text](http://i.imgur.com/wmt0U43.png)",
      "rank": -6,
      "rankName": "6 kyu",
      "tags": [
        "Fundamentals",
        "Mathematics",
        "Algorithms",
        "Logic",
        "Numbers"
      ],
      "languages": [
        "ruby",
        "python",
        "javascript",
        "coffeescript",
        "haskell",
        "csharp",
        "java",
        "clojure",
        "cpp",
        "php",
        "crystal",
        "fsharp",
        "c",
        "typescript",
        "rust",
        "swift",
        "go",
        "r",
        "shell",
        "ocaml",
        "kotlin",
        "fortran",
        "elixir",
        "julia",
        "scala",
        "powershell",
        "nim",
        "reason",
        "racket",
        "forth"
      ]
    },
    {
      "id": "5613d06cee1e7da6d5000055",
      "name": "Steps in Primes",
      "description": "The prime numbers are not regularly spaced. For example from `2` to `3` the step is `1`.\nFrom `3` to `5` the step is `2`. From `7` to `11` it is `4`.\nBetween 2 and 50 we have the following pairs of 2-steps primes:\n\n`3, 5 - 5, 7, - 11, 13, - 17, 19, - 29, 31, - 41, 43`\n\nWe will write a function `step` with parameters:\n\n- `g` (integer >= 2) which indicates the step we are looking for,\n\n- `m` (integer >= 2) which gives the start of the search (m inclusive),\n\n- `n` (integer >= m) which gives the end of the search (n inclusive)\n\nIn the example above `step(2, 2, 50)` will return `[3, 5]` which is the first pair between 2 and 50 with a 2-steps.\n\nSo this function should return the **first** pair of the two prime numbers spaced with a step of `g`\nbetween the limits `m`, `n` if these g-steps prime numbers exist otherwise `nil` or `null` or `None` or `Nothing` or `[]` or `\"0, 0\"` or `{0, 0}` or `0 0`(depending on the language). \n\n\n#Examples:\n\n- \n\n\n`step(2, 5, 7) --> [5, 7] or (5, 7) or {5, 7} or \"5 7\"`\n\n`step(2, 5, 5) --> nil or ... or [] in Ocaml or {0, 0} in C++`\n\n`step(4, 130, 200) --> [163, 167] or (163, 167) or {163, 167}`\n\n- **See more examples for your language in \"RUN\"**\n\n\n- Remarks:\n\n([193, 197] is also such a 4-steps primes between 130 and 200 but it's not the first pair).\n\n`step(6, 100, 110) --> [101, 107]` though there is a prime between 101 and 107 which is 103; the pair 101-103 is a 2-step.\n\n\n#Notes: \nThe idea of \"step\" is close to that of \"gap\" but it is not exactly the same. For those interested they can have a look\nat <http://mathworld.wolfram.com/PrimeGaps.html>. \n\nA \"gap\" is more restrictive: there must be no primes in between \n(101-107 is a \"step\" but not a \"gap\". Next kata will be about \"gaps\":-).\n\nFor Go: nil slice is expected when there are no `step` between m and n.\nExample: step(2,4900,4919) --> nil\n",
      "rank": -6,
      "rankName": "6 kyu",
      "tags": [
        "Fundamentals",
        "Numbers",
        "Data Types"
      ],
      "languages": [
        "ruby",
        "python",
        "javascript",
        "haskell",
        "csharp",
        "java",
        "clojure",
        "coffeescript",
        "cpp",
        "php",
        "crystal",
        "c",
        "ocaml",
        "fsharp",
        "typescript",
        "elixir",
        "rust",
        "swift",
        "go",
        "shell",
        "r",
        "kotlin",
        "scala",
        "julia",
        "powershell",
        "nim",
        "reason",
        "racket",
        "forth",
        "prolog",
        "fortran"
      ]
    },
    {
      "id": "5616868c81a0f281e500005c",
      "name": "Prize Draw",
      "description": "To participate in a prize draw each one gives his/her firstname. \n\nEach letter of a firstname\nhas a value which is its rank in the English alphabet. `A` and `a` have rank `1`, `B` and `b` rank `2` and so on. \n\nThe *length* of the firstname is added to the *sum* of these ranks hence a number `som`. \n\nAn array of random weights is linked to the firstnames and each `som` is multiplied by \nits corresponding weight to get what they call a `winning number`.\n\nExample:\n```\nnames: \"COLIN,AMANDBA,AMANDAB,CAROL,PauL,JOSEPH\"\nweights: [1, 4, 4, 5, 2, 1]\n\nPauL -> som = length of firstname + 16 + 1 + 21 + 12 = 4 + 50 -> 54\nThe *weight* associated with PauL is 2 so PauL's *winning number* is 54 * 2 = 108.\n```\nNow one can sort the firstnames in decreasing order of the `winning numbers`. When two\npeople have the same `winning number` sort them *alphabetically* by their firstnames.\n\n### Task:\n\n- parameters: `st` a string of firstnames, `we` an array of weights, `n` a rank \n\n- return: the firstname of the participant whose rank is `n` \n(ranks are numbered from 1)\n\n### Example:\n```\nnames: \"COLIN,AMANDBA,AMANDAB,CAROL,PauL,JOSEPH\"\nweights: [1, 4, 4, 5, 2, 1]\nn: 4\n\nThe function should return: \"PauL\"\n```\n# Notes:\n- The weight array is at least as long as the number of names, it can be longer.\n\n- If `st` is empty return \"No participants\".\n\n- If n is greater than the number of participants then return \"Not enough participants\".\n\n- See Examples Test Cases for more examples.",
      "rank": -6,
      "rankName": "6 kyu",
      "tags": [
        "Fundamentals",
        "Strings",
        "Data Types",
        "Sorting",
        "Algorithms",
        "Logic"
      ],
      "languages": [
        "ruby",
        "python",
        "javascript",
        "coffeescript",
        "haskell",
        "java",
        "csharp",
        "clojure",
        "cpp",
        "php",
        "crystal",
        "c",
        "typescript",
        "rust",
        "swift",
        "r",
        "shell",
        "fsharp",
        "ocaml",
        "scala",
        "julia",
        "powershell",
        "go",
        "nim",
        "reason",
        "racket",
        "kotlin"
      ]
    },
    {
      "id": "561e9c843a2ef5a40c0000a4",
      "name": "Gap in Primes",
      "description": "The prime numbers are not regularly spaced. For example from `2` to `3` the gap is `1`.\nFrom `3` to `5` the gap is `2`. From `7` to `11` it is `4`.\nBetween 2 and 50 we have the following pairs of 2-gaps primes:\n`3-5, 5-7, 11-13, 17-19, 29-31, 41-43`\n\nA prime gap of length n is a run of n-1 consecutive composite numbers between two **successive** primes (see: http://mathworld.wolfram.com/PrimeGaps.html).\n\nWe will write a function gap with parameters:\n\n`g` (integer >= 2) which indicates the gap we are looking for\n\n`m` (integer > 2) which gives the start of the search (m inclusive)\n\n`n` (integer >= m) which gives the end of the search (n inclusive)\n\nIn the example above `gap(2, 3, 50)` will return `[3, 5] or (3, 5) or {3, 5}` which is the first pair between 3 and 50 with a 2-gap.\n\nSo this function should return the **first** pair of two prime numbers spaced with a gap of `g`\nbetween the limits `m`, `n` if these numbers exist otherwise `nil or null or None or Nothing` (depending on the language). \n\nIn C++ return in such a case `{0, 0}`. In F# return `[||]`. In Kotlin return `[]`\n\n#Examples:\n`gap(2, 5, 7) --> [5, 7] or (5, 7) or {5, 7}`\n\n`gap(2, 5, 5) --> nil. In C++ {0, 0}. In F# [||]. In Kotlin return `[]`\n\n`gap(4, 130, 200) --> [163, 167] or (163, 167) or {163, 167}`\n\n([193, 197] is also such a 4-gap primes between 130 and 200 but it's not the first pair)\n\n`gap(6,100,110) --> nil or {0, 0}` : between 100 and 110 we have `101, 103, 107, 109` but `101-107`is not a\n6-gap because there is `103`in between and `103-109`is not a 6-gap because there is `107`in between.\n\n# Note for Go\nFor Go: nil slice is expected when there are no gap between m and n.\nExample: gap(11,30000,100000) --> nil\n\n#Ref\nhttps://en.wikipedia.org/wiki/Prime_gap\n\n",
      "rank": -5,
      "rankName": "5 kyu",
      "tags": [
        "Fundamentals",
        "Numbers",
        "Data Types"
      ],
      "languages": [
        "ruby",
        "python",
        "javascript",
        "coffeescript",
        "csharp",
        "java",
        "haskell",
        "clojure",
        "cpp",
        "php",
        "crystal",
        "c",
        "typescript",
        "rust",
        "swift",
        "go",
        "shell",
        "fsharp",
        "r",
        "ocaml",
        "kotlin",
        "scala",
        "julia",
        "powershell",
        "nim",
        "reason",
        "racket",
        "forth",
        "fortran"
      ]
    },
    {
      "id": "562e274ceca15ca6e70000d3",
      "name": "Parabolic Arc Length",
      "description": "We want to approximate the length of a curve representing a function `y = f(x)` with  ` a <= x <= b`.\nFirst, we split the interval `[a, b]` into n sub-intervals with widths \n<code>h<sub>1</sub>, h<sub>2</sub>, ... , h<sub>n</sub></code> \nby defining points \n<code>x<sub>1</sub>, x<sub>2</sub> , ... , x<sub>n-1</sub></code> between a and b. \nThis defines points \n<code>P<sub>0</sub>, P<sub>1</sub>, P<sub>2</sub>, ... , P<sub>n</sub></code> on the curve \nwhose x-coordinates are <code>a, x<sub>1</sub>, x<sub>2</sub> , ... , x<sub>n-1</sub>, b</code> \nand y-coordinates <code>f(a), f(x<sub>1</sub>), ..., f(x<sub>n-1</sub>), f(b) </code>. \nBy connecting these points, we obtain a polygonal path approximating the curve.\n\nOur task is to approximate the length of a parabolic arc representing the curve `y = x * x` with `x` in the interval `[0, 1]`. \nWe will take a common step `h` between the points <code>x<sub>i</sub>: h<sub>1</sub>, h<sub>2</sub>, ... , h<sub>n</sub> = h = 1/n</code>\nand we will consider the points \n<code>P<sub>0</sub>, P<sub>1</sub>, P<sub>2</sub>, ... , P<sub>n</sub></code> on the curve. \nThe coordinates of each <code>P<sub>i</sub></code> are <code>(x<sub>i</sub>, y<sub>i</sub> = x<sub>i</sub> * x<sub>i</sub>)</code>.\n\nThe function `len_curve` (or similar in other languages) takes `n` as parameter (number of sub-intervals) and returns the length of the curve.\nYou can truncate it to **9** decimal places.\n\n![alternative text](http://i.imgur.com/kyjJcE4.png)\n",
      "rank": -6,
      "rankName": "6 kyu",
      "tags": [
        "Fundamentals"
      ],
      "languages": [
        "ruby",
        "python",
        "javascript",
        "coffeescript",
        "haskell",
        "java",
        "csharp",
        "clojure",
        "cpp",
        "php",
        "crystal",
        "fsharp",
        "c",
        "typescript",
        "rust",
        "swift",
        "go",
        "r",
        "shell",
        "ocaml",
        "kotlin",
        "fortran",
        "elixir",
        "julia",
        "scala",
        "powershell",
        "nim",
        "purescript",
        "reason",
        "racket",
        "forth",
        "prolog",
        "haxe"
      ]
    },
    {
      "id": "562f91ff6a8b77dfe900006e",
      "name": "Going to the cinema",
      "description": "My friend John likes to go to the cinema. He can choose between system A and system B.\n```\nSystem A : he buys a ticket (15 dollars) every time\nSystem B : he buys a card (500 dollars) and a first ticket for 0.90 times the ticket price, \nthen for each additional ticket he pays 0.90 times the price paid for the previous ticket.\n```\n#Example: \nIf John goes to the cinema 3 times:\n```\nSystem A : 15 * 3 = 45\nSystem B : 500 + 15 * 0.90 + (15 * 0.90) * 0.90 + (15 * 0.90 * 0.90) * 0.90 ( = 536.5849999999999, no rounding for each ticket)\n```\nJohn wants to know how many times he must go to the cinema so that the *final result* of System B, when rounded *up* to the next dollar, will be cheaper than System A.\n\nThe function `movie` has 3 parameters: `card` (price of the card), `ticket` (normal price of \na ticket), `perc` (fraction of what he paid for the previous ticket) and returns the first `n` such that\n```\nceil(price of System B) < price of System A.\n```\nMore examples:\n```\nmovie(500, 15, 0.9) should return 43 \n    (with card the total price is 634, with tickets 645)\nmovie(100, 10, 0.95) should return 24 \n    (with card the total price is 235, with tickets 240)\n```",
      "rank": -7,
      "rankName": "7 kyu",
      "tags": [
        "Fundamentals"
      ],
      "languages": [
        "ruby",
        "python",
        "javascript",
        "haskell",
        "java",
        "csharp",
        "clojure",
        "coffeescript",
        "cpp",
        "elixir",
        "typescript",
        "php",
        "crystal",
        "fsharp",
        "c",
        "shell",
        "ocaml",
        "kotlin",
        "fortran",
        "scala",
        "julia",
        "r",
        "powershell",
        "go",
        "nim",
        "rust",
        "reason",
        "racket",
        "forth",
        "dart",
        "haxe"
      ]
    },
    {
      "id": "56347fcfd086de8f11000014",
      "name": "Euler's method for a first-order ODE",
      "description": "## Euler's Method\n\nWe want to calculate the shape of an unknown curve which starts at a given point \nwith a given slope. This curve satisfies an ordinary differential equation (ODE):\n\n```math\n\\frac{dy}{dx} = f(x, y);\\\\\ny(x_0) = y_0\n```\n\nThe starting point `$ A_0 (x_0, y_0) $` is known as well as the slope to the curve \nat `$ A_0 $` and then the tangent line at `$ A_0 $` .\n\nTake a small step along that tangent line up to a point `$ A_1 $`. Along this small step, \nthe slope does not change too much, so `$ A_1 $` will be close to the curve. \nIf we suppose that `$ A_1 $` is close enough to the curve, the same reasoning \nas for the point `$ A_1 $` above can be used for other points. \nAfter several steps, a polygonal curve `$ A_0, A_1, ..., A_n $` is computed. \nThe error between the two curves will be small if the step is small.\n\nWe define points `$ A_0, A_1, A_2, ..., A_n $`\nwhose x-coordinates are `$ x_0, x_1, ..., x_n $`\nand y-coordinates are such that `$ y_{k+1} = y_k + f(x_k, y_k) \\times h $` \nwhere `$ h $` is the common step. If `$ T $` is the length `$ x_n - x_0 $` we have `$ h = T/n $`.\n\n## Task\n\nFor this kata we will focus on the following differential equation:\n\n```math\n\\frac{dy}{dx} = 2 - e^{-4x} - 2y; \\\\\nA_0 = (0,1)\n```\nwith `$ x ∈ [0, 1] $`. We will then take a uniform partition of the region of `$ x $` between `$ 0 $` and `$ 1 $` and split it into `$ n $` + 1 sections. `$ n $` will be the input to the function `ex_euler(n)` and since `$ T $` is always 1, `$ h = 1/n $`.\n\n\n\nWe know that an exact solution is\n```math\ny = 1 + 0.5e^{-4x} - 0.5e^{-2x}.\n```\nFor each `$ x_k $` we are able to calculate the `$ y_k $` as well as the values `$ z_k $` of the exact solution.\n\nOur task is, for a given number `$ n $` of steps, to return the mean (*truncated* to 6 decimal places)\nof the relative errors between the `$ y_k $` (our aproximation) and the `$ z_k $` (the exact solution). \nFor that we can use:\n\nerror in `$ A_k = abs(y_k - z_k) / z_k $` and then the mean is sum(errors in `$ A_k $`)/ (`$ n $` + 1)\n\n## Examples\n\n```python\nex_euler(10) should return: 0.026314 (truncated from 0.026314433214799246)\nwith\nY = [1.0,0.9..., 0.85..., 0.83..., 0.83..., 0.85..., 0.86..., 0.88..., 0.90..., 0.91..., 0.93...]\nZ = [1.0, 0.9..., 0.88..., 0.87..., 0.87..., 0.88..., 0.89..., 0.90..., 0.91..., 0.93..., 0.94...]\nRelative errors = [0.0, 0.02..., 0.04..., 0.04..., 0.04..., 0.03..., 0.03..., 0.02..., 0.01..., 0.01..., 0.01...]\n```\n`ex_euler(17)` should return: `0.015193 (truncated from 0.015193336263370796)`.\nAs expected, as `$ n $` increases, our error reduces.\n### Links and graphs\n\n\n\n<a href=\"https://en.wikipedia.org/wiki/Euler_method\">Wiki article</a>\n\n![alternative text](http://i.imgur.com/vjK7edl.png)\n\nBelow comparison between approximation (red curve) and exact solution(blue curve) for n=100:\n![alternative text](http://i.imgur.com/KufSkYEm.png)",
      "rank": -5,
      "rankName": "5 kyu",
      "tags": [
        "Algorithms"
      ],
      "languages": [
        "ruby",
        "python",
        "javascript",
        "coffeescript",
        "haskell",
        "java",
        "csharp",
        "clojure",
        "cpp",
        "php",
        "crystal",
        "c",
        "typescript",
        "fsharp",
        "r",
        "shell",
        "ocaml",
        "swift",
        "powershell",
        "julia",
        "go",
        "nim",
        "rust",
        "reason",
        "forth",
        "scala",
        "kotlin",
        "prolog",
        "fortran",
        "haxe"
      ]
    },
    {
      "id": "5629db57620258aa9d000014",
      "name": "Strings Mix",
      "description": "Given two strings s1 and s2, we want to visualize how different the two strings are.\nWe will only take into account the *lowercase* letters (a to z).\nFirst let us count the frequency of each *lowercase* letters in s1 and s2.\n\n`s1 = \"A aaaa bb c\"`\n\n`s2 = \"& aaa bbb c d\"`\n\n`s1 has 4 'a', 2 'b', 1 'c'`\n\n`s2 has 3 'a', 3 'b', 1 'c', 1 'd'`\n\nSo the maximum for 'a' in s1 and s2 is 4 from s1; the maximum for 'b' is 3 from s2.\nIn the following we will not consider letters when the maximum of their occurrences\nis less than or equal to 1.\n\nWe can resume the differences between s1 and s2 in the following string:\n`\"1:aaaa/2:bbb\"`\nwhere `1` in `1:aaaa` stands for string s1 and `aaaa` because the maximum for `a` is 4.\nIn the same manner `2:bbb` stands for string s2 and `bbb` because the maximum for `b` is 3.\n\nThe task is to produce a string in which each *lowercase* letters of s1 or s2 appears as many times as\nits maximum if this maximum is *strictly greater than 1*; these letters will be prefixed by the \nnumber of the string where they appear with their maximum value and `:`. \nIf the maximum is in s1 as well as in s2 the prefix is `=:`.\n\nIn the result, substrings (a substring is for example 2:nnnnn or 1:hhh; it contains the prefix) will be in decreasing order of their length and when they have the same length sorted in ascending lexicographic order (letters and digits - more precisely sorted by codepoint); the different groups will be separated by '/'. See examples and \"Example Tests\".\n\nHopefully other examples can make this clearer.\n\n```\ns1 = \"my&friend&Paul has heavy hats! &\"\ns2 = \"my friend John has many many friends &\"\nmix(s1, s2) --> \"2:nnnnn/1:aaaa/1:hhh/2:mmm/2:yyy/2:dd/2:ff/2:ii/2:rr/=:ee/=:ss\"\n\ns1 = \"mmmmm m nnnnn y&friend&Paul has heavy hats! &\"\ns2 = \"my frie n d Joh n has ma n y ma n y frie n ds n&\"\nmix(s1, s2) --> \"1:mmmmmm/=:nnnnnn/1:aaaa/1:hhh/2:yyy/2:dd/2:ff/2:ii/2:rr/=:ee/=:ss\"\n\ns1=\"Are the kids at home? aaaaa fffff\"\ns2=\"Yes they are here! aaaaa fffff\"\nmix(s1, s2) --> \"=:aaaaaa/2:eeeee/=:fffff/1:tt/2:rr/=:hh\"\n```\n# Note for Swift, R, PowerShell\nThe prefix `=:` is replaced by `E:`\n``` \ns1 = \"mmmmm m nnnnn y&friend&Paul has heavy hats! &\"\ns2 = \"my frie n d Joh n has ma n y ma n y frie n ds n&\"\nmix(s1, s2) --> \"1:mmmmmm/E:nnnnnn/1:aaaa/1:hhh/2:yyy/2:dd/2:ff/2:ii/2:rr/E:ee/E:ss\"\n```\n",
      "rank": -4,
      "rankName": "4 kyu",
      "tags": [
        "Fundamentals",
        "Strings",
        "Data Types"
      ],
      "languages": [
        "ruby",
        "python",
        "javascript",
        "haskell",
        "java",
        "clojure",
        "coffeescript",
        "csharp",
        "cpp",
        "php",
        "crystal",
        "c",
        "typescript",
        "rust",
        "swift",
        "shell",
        "ocaml",
        "r",
        "kotlin",
        "fsharp",
        "scala",
        "julia",
        "powershell",
        "go",
        "nim",
        "racket",
        "reason",
        "elixir"
      ]
    },
    {
      "id": "562b384167350ac93b00010c",
      "name": "Weird prime generator",
      "description": "Consider the sequence `a(1) = 7, a(n) = a(n-1) + gcd(n, a(n-1)) for n >= 2`: \n\n`7, 8, 9, 10, 15, 18, 19, 20, 21, 22, 33, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 69, 72, 73...`.\n\nLet us take the differences between successive elements of the sequence and\nget a second sequence `g: 1, 1, 1, 5, 3, 1, 1, 1, 1, 11, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 23, 3, 1...`.\n\nFor the sake of uniformity of the lengths of sequences **we add** a `1` at the head of g:\n\n`g: 1, 1, 1, 1, 5, 3, 1, 1, 1, 1, 11, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 23, 3, 1...`\n\nRemoving the 1s gives a third sequence:\n`p: 5, 3, 11, 3, 23, 3...`\nwhere you can see prime numbers.\n\n#Task:\nWrite functions:\n```\n1: an(n) with parameter n: returns the first n terms of the series a(n) (not tested)\n\n2: gn(n) with parameter n: returns the first n terms of the series g(n) (not tested)\n\n3: countOnes(n) with parameter n: returns the number of 1 in g(n) \n    (don't forget to add a `1` at the head) # (tested)\n    \n4: p(n) with parameter n: returns an array of n unique prime numbers (not tested)\n\n5: maxp(n) with parameter n: returns the biggest prime number of the sequence pn(n) # (tested)\n\n6: anOver(n) with parameter n: returns an array (n terms) of the a(i)/i for every i such g(i) != 1 (not tested but interesting result)\n\n7: anOverAverage(n) with parameter n: returns as an *integer* the average of anOver(n)  (tested)\n```\n\n#Note:\nYou can write directly functions `3:`, `5:` and `7:`. There is no need to write functions `1:`, `2:`, `4:` `6:`\nexcept out of pure curiosity.",
      "rank": -5,
      "rankName": "5 kyu",
      "tags": [
        "Fundamentals"
      ],
      "languages": [
        "ruby",
        "python",
        "javascript",
        "coffeescript",
        "haskell",
        "csharp",
        "java",
        "clojure",
        "cpp",
        "php",
        "c",
        "typescript",
        "rust",
        "swift",
        "crystal",
        "fsharp",
        "shell",
        "ocaml",
        "go",
        "nim",
        "scala"
      ]
    },
    {
      "id": "564057bc348c7200bd0000ff",
      "name": "A Rule of Divisibility by 13",
      "description": "When you divide the successive powers of `10` by `13` you get the following remainders of the integer divisions:  \n\n`1, 10, 9, 12, 3, 4`. \n\nThen the whole pattern repeats.\n\nHence the following method:\nMultiply the right most digit of the number with the left most number \nin the sequence shown above, the second right most digit to the second \nleft most digit of the number in the sequence. The cycle goes on and you sum all these products. Repeat this process until the sequence of sums is stationary.\n\n...........................................................................\n\nExample: What is the remainder when `1234567` is divided by `13`?\n\n`7×1 + 6×10 + 5×9 + 4×12 + 3×3 + 2×4 + 1×1 = 178`\n\nWe repeat the process with 178:\n\n`8x1 + 7x10 + 1x9 = 87`\n\nand again with 87:\n\n`7x1 + 8x10 = 87`\n\n...........................................................................\n\nFrom now on the sequence is stationary and the remainder of `1234567` by `13` is \nthe same as the remainder of `87` by `13`: `9`\n\nCall `thirt` the function which processes this sequence of operations on an integer `n (>=0)`. `thirt` will return the stationary number.\n\n`thirt(1234567)` calculates 178, then 87, then 87 and returns `87`.\n\n`thirt(321)` calculates 48, 48 and returns `48`\n",
      "rank": -6,
      "rankName": "6 kyu",
      "tags": [
        "Fundamentals"
      ],
      "languages": [
        "ruby",
        "python",
        "javascript",
        "haskell",
        "csharp",
        "java",
        "coffeescript",
        "clojure",
        "elixir",
        "cpp",
        "typescript",
        "php",
        "crystal",
        "fsharp",
        "c",
        "rust",
        "swift",
        "go",
        "shell",
        "r",
        "ocaml",
        "kotlin",
        "julia",
        "fortran",
        "scala",
        "powershell",
        "nim",
        "reason",
        "racket",
        "forth",
        "prolog",
        "haxe"
      ]
    },
    {
      "id": "563f0c54a22b9345bf000053",
      "name": "A disguised sequence (I)",
      "description": "Given <code>u<sub>0</sub> = 1, u<sub>1</sub> = 2</code> and the relation\n<code>6u<sub>n</sub>u<sub>n+1</sub>-5u<sub>n</sub>u<sub>n+2</sub>+u<sub>n+1</sub>u<sub>n+2</sub> = 0</code>\ncalculate <code>u<sub>n</sub> for any integer n >= 0</code>.\n#### Example\n\nfcn(n) returns <code>u<sub>n</sub></code>: \n` fcn(17) -> 131072, fcn(21) -> 2097152`\n\n#### Remarks\nYou can take two points of view to do this kata: \n\n- the first one purely algorithmic from the definition of <code>u<sub>n</sub></code>\n\n- the second one - not at all mandatory, but as a complement - is to get a bit your head around and find which sequence is hidden behind <code>u<sub>n</sub></code>. \n",
      "rank": -6,
      "rankName": "6 kyu",
      "tags": [
        "Algorithms",
        "Sequences",
        "Arrays",
        "Data Types"
      ],
      "languages": [
        "ruby",
        "python",
        "javascript",
        "coffeescript",
        "haskell",
        "java",
        "csharp",
        "clojure",
        "elixir",
        "typescript",
        "cpp",
        "php",
        "crystal",
        "fsharp",
        "c",
        "ocaml",
        "rust",
        "swift",
        "go",
        "shell",
        "r",
        "nim",
        "kotlin",
        "objc",
        "fortran",
        "nasm",
        "julia",
        "scala",
        "lua",
        "powershell",
        "racket",
        "forth",
        "factor",
        "prolog",
        "haxe"
      ]
    },
    {
      "id": "563b662a59afc2b5120000c6",
      "name": "Growth of a Population",
      "description": "In a small town the population is `p0 = 1000` at the beginning of a year. The population\nregularly increases by `2 percent` per year and moreover `50` new inhabitants per year\ncome to live in the town. \nHow many years does the town need to see its population\ngreater or equal to `p = 1200` inhabitants?\n\n```\nAt the end of the first year there will be: \n1000 + 1000 * 0.02 + 50 => 1070 inhabitants\n\nAt the end of the 2nd year there will be: \n1070 + 1070 * 0.02 + 50 => 1141 inhabitants (number of inhabitants is an integer)\n\nAt the end of the 3rd year there will be:\n1141 + 1141 * 0.02 + 50 => 1213\n\nIt will need 3 entire years.\n```\nMore generally given parameters:\n\n`p0, percent, aug (inhabitants coming or leaving each year), p (population to surpass)`\n\nthe function `nb_year` should return `n` number of entire years needed to\nget a population greater or equal to `p`.\n\naug is an integer, percent a positive or null number, p0 and p are positive integers (> 0)\n```\nExamples:\nnb_year(1500, 5, 100, 5000) -> 15\nnb_year(1500000, 2.5, 10000, 2000000) -> 10\n```\n\nNote: Don't forget to convert the percent parameter as a percentage in the body of your function: if the parameter percent is 2 you have to convert it to 0.02.",
      "rank": -7,
      "rankName": "7 kyu",
      "tags": [
        "Fundamentals"
      ],
      "languages": [
        "ruby",
        "python",
        "javascript",
        "coffeescript",
        "haskell",
        "java",
        "csharp",
        "clojure",
        "cpp",
        "php",
        "crystal",
        "fsharp",
        "c",
        "typescript",
        "r",
        "nim",
        "shell",
        "ocaml",
        "lua",
        "kotlin",
        "fortran",
        "elixir",
        "julia",
        "powershell",
        "go",
        "rust",
        "reason",
        "racket",
        "forth",
        "factor",
        "dart",
        "elm",
        "scala",
        "prolog",
        "haxe"
      ]
    },
    {
      "id": "56445c4755d0e45b8c00010a",
      "name": "Banker's Plan",
      "description": "John has some amount of money of which he wants to deposit a part `f0` to the bank at the beginning\nof year `1`. He wants to withdraw each year for his living an amount `c0`.\n\nHere is his banker plan:\n\n- deposit `f0` at beginning of year 1\n- his bank account has an interest rate of `p` percent per year, constant over the years\n- John can withdraw each year `c0`, taking it whenever he wants in the year; he must take account of an inflation of `i` percent per year in order to keep his quality of living. `i` is supposed to stay constant over the years.\n- all amounts <code>f<sub>0</sub></code>..<code>f<sub>n-1</sub></code>, <code>c<sub>0</sub></code>..<code>c<sub>n-1</sub></code> are truncated by the bank to their integral part\n- Given <code>f<sub>0</sub></code>, `p`, <code>c<sub>0</sub></code>, `i` \nthe banker guarantees that John will be able to go on that way until the `nth` year.\n\n# Example:\n\n```\nf0 = 100000, p = 1 percent, c0 = 2000, n = 15, i = 1 percent\n```\n\n```\nbeginning of year 2 -> f1 = 100000 + 0.01*100000 - 2000 = 99000;  c1 = c0 + c0*0.01 = 2020 (with inflation of previous year)\n```\n\n```\nbeginning of year 3 -> f2 =  99000 + 0.01*99000 - 2020  = 97970;  c2 = c1 + c1*0.01 = 2040.20 \n(with inflation of previous year, truncated to 2040)\n```\n\n```\nbeginning of year 4 -> f3 =  97970 + 0.01*97970 - 2040  = 96909.7 (truncated to 96909); \nc3 = c2 + c2*0.01 = 2060.4 (with inflation of previous year, truncated to 2060)\n```\nand so on...\n\nJohn wants to know if the banker's plan is right or wrong.\nGiven parameters `f0, p, c0, n, i` build a function `fortune` which returns `true` if John can make a living until the `nth` year\nand `false` if it is not possible.\n\n# Some cases:\n```\nfortune(100000, 1, 2000, 15, 1) -> True\nfortune(100000, 1, 10000, 10, 1) -> True\nfortune(100000, 1, 9185, 12, 1) -> False\n\nFor the last case you can find below the amounts of his account at the beginning of each year:\n100000, 91815, 83457, 74923, 66211, 57318, 48241, 38977, 29523, 19877, 10035, -5\n```\n<pre><code>f<sub>11</sub> = -5 so he has no way to withdraw something for his living in year 12.</code></pre>\n\n> **Note:** Don't forget to convert the percent parameters as percentages in the body of your function: if a parameter percent is 2 you have to convert it to 0.02.",
      "rank": -6,
      "rankName": "6 kyu",
      "tags": [
        "Algorithms",
        "Mathematics",
        "Logic",
        "Numbers",
        "Data Types"
      ],
      "languages": [
        "ruby",
        "python",
        "javascript",
        "java",
        "csharp",
        "haskell",
        "coffeescript",
        "clojure",
        "elixir",
        "typescript",
        "cpp",
        "php",
        "crystal",
        "fsharp",
        "c",
        "rust",
        "swift",
        "go",
        "shell",
        "r",
        "ocaml",
        "kotlin",
        "fortran",
        "julia",
        "scala",
        "powershell",
        "nim",
        "reason",
        "racket",
        "forth",
        "prolog",
        "haxe"
      ]
    },
    {
      "id": "56484848ba95170a8000004d",
      "name": "Speed Control",
      "description": "In John's car the GPS records every `s` seconds the distance travelled from an origin (distances are measured in an arbitrary but consistent unit).\nFor example, below is part of a record with `s = 15`:\n\n    x = [0.0, 0.19, 0.5, 0.75, 1.0, 1.25, 1.5, 1.75, 2.0, 2.25]\nThe sections are:\n\n    0.0-0.19, 0.19-0.5, 0.5-0.75, 0.75-1.0, 1.0-1.25, 1.25-1.50, 1.5-1.75, 1.75-2.0, 2.0-2.25\n  \nWe can calculate John's average hourly speed on every section and we get:\n\n    [45.6, 74.4, 60.0, 60.0, 60.0, 60.0, 60.0, 60.0, 60.0]\nGiven `s` and `x` the task is to return as an integer the `*floor*` of the maximum average speed per hour obtained on the sections of `x`. \nIf x length is less than or equal to 1 return `0` since the car didn't move.\n\n# Example:\nwith the above data your function `gps(s, x)`should return `74`\n\n# Note\nWith floats it can happen that results depends on the operations order. To calculate hourly speed you can use: \n\n` (3600 * delta_distance) / s`.\n",
      "rank": -7,
      "rankName": "7 kyu",
      "tags": [
        "Fundamentals"
      ],
      "languages": [
        "ruby",
        "python",
        "javascript",
        "haskell",
        "csharp",
        "java",
        "coffeescript",
        "clojure",
        "cpp",
        "php",
        "elixir",
        "crystal",
        "fsharp",
        "c",
        "typescript",
        "ocaml",
        "shell",
        "kotlin",
        "julia",
        "r",
        "powershell",
        "go",
        "nim",
        "rust",
        "reason",
        "racket",
        "scala"
      ]
    },
    {
      "id": "56541980fa08ab47a0000040",
      "name": "Printer Errors",
      "description": "In a factory a printer prints labels for boxes. For one kind of boxes\nthe printer has to use colors which, for the sake of simplicity,\nare named with letters from `a to m`. \n\nThe colors used by the printer are\nrecorded in a control string. For example a \"good\" control string would be\n`aaabbbbhaijjjm` meaning that the printer used three times color a, four times\ncolor b, one time color h then one time color a...\n\nSometimes there are problems: lack of colors, technical malfunction and a \"bad\" \ncontrol string is produced e.g. `aaaxbbbbyyhwawiwjjjwwm` with letters not from `a to m`.\n\nYou have to write a function `printer_error` which given a string will return\nthe error rate of the printer as a **string** representing a rational whose numerator \nis the number of errors and the denominator the length of the control string.\nDon't reduce this fraction to a simpler expression.\n\nThe string has a length greater or equal to one and contains only letters \nfrom `a`to `z`.\n\n## Examples:\n\n```\ns=\"aaabbbbhaijjjm\"\nerror_printer(s) => \"0/14\"\n\ns=\"aaaxbbbbyyhwawiwjjjwwm\"\nerror_printer(s) => \"8/22\"\n\n```",
      "rank": -7,
      "rankName": "7 kyu",
      "tags": [
        "Fundamentals"
      ],
      "languages": [
        "ruby",
        "python",
        "javascript",
        "coffeescript",
        "csharp",
        "java",
        "haskell",
        "clojure",
        "elixir",
        "typescript",
        "cpp",
        "php",
        "crystal",
        "fsharp",
        "c",
        "shell",
        "ocaml",
        "groovy",
        "nasm",
        "julia",
        "go",
        "r",
        "kotlin",
        "powershell",
        "nim",
        "reason",
        "racket",
        "rust",
        "scala",
        "dart",
        "swift",
        "haxe"
      ]
    },
    {
      "id": "5663f5305102699bad000056",
      "name": "Maximum Length Difference",
      "description": "You are given two arrays `a1` and `a2` of strings. Each string is composed with letters from `a` to `z`.\nLet `x` be any string in the first array and `y` be any string in the second array. \n\n  `Find max(abs(length(x) − length(y)))`\n\nIf `a1` and/or `a2` are empty return `-1` in each language\nexcept in Haskell (F#) where you will return `Nothing` (None).\n\n# Example:\n```\na1 = [\"hoqq\", \"bbllkw\", \"oox\", \"ejjuyyy\", \"plmiis\", \"xxxzgpsssa\", \"xxwwkktt\", \"znnnnfqknaz\", \"qqquuhii\", \"dvvvwz\"]\na2 = [\"cccooommaaqqoxii\", \"gggqaffhhh\", \"tttoowwwmmww\"]\nmxdiflg(a1, a2) --> 13\n\n```\n\n# Bash note:\n - input : 2 strings with substrings separated by `,`\n - output: number as a string",
      "rank": -7,
      "rankName": "7 kyu",
      "tags": [
        "Fundamentals"
      ],
      "languages": [
        "ruby",
        "python",
        "javascript",
        "coffeescript",
        "csharp",
        "haskell",
        "java",
        "clojure",
        "cpp",
        "php",
        "crystal",
        "c",
        "typescript",
        "fsharp",
        "shell",
        "ocaml",
        "kotlin",
        "elixir",
        "julia",
        "r",
        "scala",
        "powershell",
        "go",
        "nim",
        "rust",
        "reason",
        "racket",
        "haxe"
      ]
    },
    {
      "id": "5656b6906de340bd1b0000ac",
      "name": "Two to One",
      "description": "Take 2 strings `s1` and `s2` including only letters from `a`to `z`.\nReturn a new **sorted** string, the longest possible, containing distinct letters,\n- each taken only once - coming from s1 or s2.\n\n# Examples:\n```\na = \"xyaabbbccccdefww\"\nb = \"xxxxyyyyabklmopq\"\nlongest(a, b) -> \"abcdefklmopqwxy\"\n\na = \"abcdefghijklmnopqrstuvwxyz\"\nlongest(a, a) -> \"abcdefghijklmnopqrstuvwxyz\"\n```\n",
      "rank": -7,
      "rankName": "7 kyu",
      "tags": [
        "Fundamentals"
      ],
      "languages": [
        "java",
        "csharp",
        "ruby",
        "python",
        "javascript",
        "coffeescript",
        "haskell",
        "clojure",
        "cpp",
        "php",
        "crystal",
        "fsharp",
        "c",
        "elixir",
        "typescript",
        "shell",
        "ocaml",
        "kotlin",
        "julia",
        "go",
        "r",
        "rust",
        "scala",
        "powershell",
        "nim",
        "reason",
        "racket",
        "dart"
      ]
    },
    {
      "id": "565abd876ed46506d600000d",
      "name": "Simpson's Rule - Approximate Integration",
      "description": "An integral:\n  \n<img src=\"https://latex.codecogs.com/gif.latex?\\bg_white&space;\\int_{a}^{b}f(x)dx\" title=\"\\bg_white \\int_{a}^{b}f(x)dx\" \n     />\n\ncan be approximated by the so-called Simpson’s rule:\n\n<img src=\"http://latex.codecogs.com/gif.latex?\\bg_white&space;\\frac{b-a}{3n}(f(a)&plus;f(b)&plus;4\\sum_{i=1}^{n/2}f(a&plus;(2i-1)h)&plus;\n    2\\sum_{i=1}^{n/2-1}f(a&plus;2ih))\" title=\"\\frac{b-a}{3n}\n(f(a)+f(b)+4\\sum_{i=1}^{n/2}f(a+(2i-1)h)+2\\sum_{i=1}^{n/2-1}f(a+2ih))\" /></a>\n\n\nHere `h = (b-a)/n`, `n` being an even integer and `a <= b`. \n\nWe want to try Simpson's rule with the function f:\n\n<img src=\"http://latex.codecogs.com/gif.latex?\\bg_white&space;f(x)&space;=&space;\\frac{3}{2}sin^3x\" title=\"f(x) = \\frac{3}{2}sin^3x\" /></a>\n\nThe task is to write a function called `simpson` with parameter `n` which returns the value of the integral of f on the interval `[0, pi]` (pi being 3.14159265359...).\n## Notes:\n- Don't round or truncate your results. See in \"RUN EXAMPLES\" the function `assertFuzzyEquals` or `testing`.\n- `n` will always be even.\n\n- We know that the exact value of the integral of f on the given interval is `2`.\n\nYou can see: <http://www.codewars.com/kata/5562ab5d6dca8009f7000050/train/javascript>\nabout rectangle method and trapezoidal rule.",
      "rank": -6,
      "rankName": "6 kyu",
      "tags": [
        "Fundamentals"
      ],
      "languages": [
        "ruby",
        "python",
        "javascript",
        "coffeescript",
        "java",
        "csharp",
        "haskell",
        "clojure",
        "cpp",
        "php",
        "crystal",
        "elixir",
        "fsharp",
        "c",
        "typescript",
        "rust",
        "swift",
        "go",
        "r",
        "shell",
        "ocaml",
        "kotlin",
        "fortran",
        "julia",
        "scala",
        "powershell",
        "nim",
        "reason",
        "racket",
        "forth",
        "prolog",
        "haxe"
      ]
    }
  ]
}